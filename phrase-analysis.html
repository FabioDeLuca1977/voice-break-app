<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Break AI - Analisi per Frasi</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .main-panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #e9ecef;
        }

        .control-section h3 {
            margin-bottom: 15px;
            color: #495057;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: center;
            width: 100%;
            margin-bottom: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn.recording {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            animation: pulse 1.5s infinite;
        }

        .btn.phrase-analysis {
            background: linear-gradient(45deg, #00b894, #00a085);
        }

        .btn.auto-detect {
            background: linear-gradient(45deg, #6c5ce7, #a29bfe);
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .voice-selector {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .voice-card {
            padding: 15px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            text-align: center;
        }

        .voice-card.selected {
            border-color: #667eea;
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .voice-card.aria { background: linear-gradient(135deg, #87CEEB, #4682B4); color: white; }
        .voice-card.acqua { background: linear-gradient(135deg, #20B2AA, #008B8B); color: white; }
        .voice-card.terra { background: linear-gradient(135deg, #D2691E, #8B4513); color: white; }
        .voice-card.fuoco { background: linear-gradient(135deg, #FF6347, #DC143C); color: white; }

        .audio-visualizer {
            height: 60px;
            background: #f8f9fa;
            border-radius: 8px;
            margin: 15px 0;
            position: relative;
            overflow: hidden;
        }

        .audio-bar {
            position: absolute;
            bottom: 0;
            width: 3px;
            background: linear-gradient(to top, #667eea, #764ba2);
            transition: height 0.1s ease;
        }

        .timer-display {
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            color: #495057;
            font-family: monospace;
        }

        .auto-detection-result {
            background: linear-gradient(135deg, #6c5ce7, #a29bfe);
            color: white;
            padding: 20px;
            border-radius: 15px;
            margin: 15px 0;
            text-align: center;
            display: none;
        }

        .detected-voice {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .confidence-score {
            font-size: 1.2em;
            margin-bottom: 5px;
        }

        .voice-breakdown {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .voice-score {
            background: rgba(255, 255, 255, 0.2);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }

        .debug-section {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }

        .debug-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #495057;
        }

        .debug-log {
            color: #6c757d;
            line-height: 1.4;
        }

        .error-message, .success-message, .warning-message {
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            display: none;
        }

        .error-message { background: #ff6b6b; color: white; }
        .success-message { background: #00b894; color: white; }
        .warning-message { background: #ffa726; color: white; }

        .processing-indicator {
            display: none;
            text-align: center;
            margin: 20px 0;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .phrase-results {
            margin-top: 30px;
            display: none;
        }

        .phrases-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .summary-card {
            background: white;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }

        .summary-number {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .summary-label {
            color: #6c757d;
            font-size: 0.9em;
        }

        .phrase-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .phrase-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }

        .phrase-card.trend-ascending { border-left-color: #87CEEB; }
        .phrase-card.trend-descending { border-left-color: #20B2AA; }
        .phrase-card.trend-stable { border-left-color: #D2691E; }
        .phrase-card.trend-dynamic { border-left-color: #FF6347; }

        .phrase-title {
            font-weight: bold;
            color: #495057;
            margin-bottom: 5px;
        }

        .phrase-trend {
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .trend-ascending { color: #4682B4; }
        .trend-descending { color: #008B8B; }
        .trend-stable { color: #8B4513; }
        .trend-dynamic { color: #DC143C; }

        .phrase-controls {
            margin-top: 10px;
            display: flex;
            gap: 5px;
        }

        .speak-btn {
            background: linear-gradient(45deg, #6c757d, #495057);
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .speak-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 8px rgba(108, 117, 125, 0.4);
        }

        .speak-btn.speaking {
            background: linear-gradient(45deg, #28a745, #20c997);
            animation: pulse-speak 1s infinite;
        }

        @keyframes pulse-speak {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .tts-controls {
            background: #e9ecef;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
        }

        .tts-controls h4 {
            margin-bottom: 10px;
            color: #495057;
        }

        .voice-settings {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-bottom: 10px;
        }

        .voice-setting {
            display: flex;
            flex-direction: column;
        }

        .voice-setting label {
            font-size: 12px;
            color: #6c757d;
            margin-bottom: 3px;
        }

        .voice-setting input, .voice-setting select {
            padding: 5px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            font-size: 14px;
        }

        .chart-container {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            height: 500px;
            position: relative;
            overflow: hidden;
        }

        .chart-scroll-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(255,255,255,0.95);
            border-radius: 8px;
            padding: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: flex;
            gap: 5px;
            z-index: 20;
            backdrop-filter: blur(5px);
        }

        .chart-scroll-controls button {
            border: none;
            background: #667eea;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .chart-scroll-controls button:hover {
            background: #5a6fd8;
            transform: translateY(-1px);
        }

        .chart-scroll-controls button:active {
            transform: translateY(0);
        }

        .phrase-overlay {
            position: absolute;
            background: rgba(255,255,255,0.95);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 11px;
            font-weight: bold;
            color: #333;
            pointer-events: none;
            z-index: 10;
            max-width: 200px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
        }

        .phrase-overlay:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(0,0,0,0.25);
        }

        /* 🆕 Indicatore di scroll per grafici lunghi */
        .chart-timeline-indicator {
            position: absolute;
            bottom: 45px;
            left: 20px;
            right: 80px;
            height: 6px;
            background: rgba(0,0,0,0.1);
            border-radius: 3px;
            z-index: 15;
            cursor: pointer;
        }

        .chart-timeline-thumb {
            height: 100%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border-radius: 3px;
            transition: all 0.3s ease;
            cursor: grab;
            position: relative;
        }

        .chart-timeline-thumb:hover {
            background: linear-gradient(45deg, #5a6fd8, #6a4190);
            transform: scaleY(1.2);
        }

        .chart-timeline-thumb:active {
            cursor: grabbing;
        }

        /* 🆕 Hints navigazione */
        .navigation-hints {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 11px;
            z-index: 25;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            line-height: 1.4;
        }

        /* 🆕 Pulsante fullscreen */
        .chart-fullscreen-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255,255,255,0.9);
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 16px;
            z-index: 20;
            transition: all 0.3s ease;
        }

        .chart-fullscreen-btn:hover {
            background: rgba(102, 126, 234, 0.1);
            border-color: #667eea;
            transform: scale(1.1);
        }

        /* 🆕 Stili per fullscreen */
        .chart-container:fullscreen {
            height: 100vh;
            width: 100vw;
            padding: 40px;
            border-radius: 0;
        }

        .chart-container:-webkit-full-screen {
            height: 100vh;
            width: 100vw;
            padding: 40px;
            border-radius: 0;
        }

        /* 🆕 Focus styles per navigazione keyboard */
        .chart-container:focus {
            outline: 2px solid #667eea;
            outline-offset: 2px;
        }

        @media (max-width: 768px) {
            .controls-grid {
                grid-template-columns: 1fr;
            }
            
            .voice-selector {
                grid-template-columns: 1fr;
            }
            
            .phrases-summary {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎤 Voice Break AI</h1>
            <p>Analisi Vocale Basata su Frasi per le 4 Voci Elementali</p>
        </div>

        <div class="main-panel">
            <div class="controls-grid">
                <div class="control-section">
                    <h3>🎙️ Registrazione Audio</h3>
                    <button id="testMicrophone" class="btn">
                        <span>🔧</span>
                        Test Microfono
                    </button>
                    <button id="startRecording" class="btn">
                        <span>▶️</span>
                        Inizia Registrazione
                    </button>
                    <button id="stopRecording" class="btn" disabled>
                        <span>⏹️</span>
                        Stop Registrazione
                    </button>
                    <button id="autoDetectVoice" class="btn auto-detect" disabled>
                        <span>🎯</span>
                        Auto-Rileva Voce
                    </button>
                    <div class="audio-visualizer" id="audioVisualizer"></div>
                    <div class="timer-display" id="recordingTime">00:00</div>
                </div>

                <div class="control-section">
                    <h3>🎯 Voce Target (Opzionale)</h3>
                    <div class="voice-selector">
                        <div class="voice-card aria" data-voice="ARIA">
                            <div><strong>🌬️ ARIA</strong></div>
                            <small>Apertura & Connessione</small>
                        </div>
                        <div class="voice-card acqua" data-voice="ACQUA">
                            <div><strong>💧 ACQUA</strong></div>
                            <small>Condivisione & Ascolto</small>
                        </div>
                        <div class="voice-card terra" data-voice="TERRA">
                            <div><strong>🌍 TERRA</strong></div>
                            <small>Chiarezza & Struttura</small>
                        </div>
                        <div class="voice-card fuoco" data-voice="FUOCO">
                            <div><strong>🔥 FUOCO</strong></div>
                            <small>Energia & Decisione</small>
                        </div>
                    </div>
                    <small style="color: #6c757d;">💡 Puoi anche usare l'auto-rilevamento senza selezionare una voce</small>
                </div>

                <div class="control-section">
                    <h3>🔬 Analisi Frasi</h3>
                    <button id="analyzePhrases" class="btn phrase-analysis" disabled>
                        <span>🎯</span>
                        Analizza per Frasi
                    </button>
                    <button id="clearResults" class="btn">
                        <span>🔄</span>
                        Reset Risultati
                    </button>
                    <label class="btn" for="fileInput" style="margin-bottom: 0;">
                        <span>📁</span>
                        Carica Audio
                    </label>
                    <input type="file" id="fileInput" accept="audio/*" style="display: none;">
                    
                    <div class="tts-controls">
                        <h4>🔊 Text-to-Speech</h4>
                        <div class="voice-settings">
                            <div class="voice-setting">
                                <label>Velocità</label>
                                <input type="range" id="speechRate" min="0.5" max="2" step="0.1" value="1">
                            </div>
                            <div class="voice-setting">
                                <label>Pitch</label>
                                <input type="range" id="speechPitch" min="0.5" max="2" step="0.1" value="1">
                            </div>
                            <div class="voice-setting">
                                <label>Volume</label>
                                <input type="range" id="speechVolume" min="0" max="1" step="0.1" value="0.8">
                            </div>
                            <div class="voice-setting">
                                <label>Voce</label>
                                <select id="speechVoice">
                                    <option value="">Default</option>
                                </select>
                            </div>
                        </div>
                        <button id="speakAllPhrases" class="btn" disabled>
                            <span>🎤</span>
                            Leggi Tutte le Frasi
                        </button>
                    </div>
                </div>
            </div>

            <div class="auto-detection-result" id="autoDetectionResult">
                <div class="detected-voice" id="detectedVoice">🎤 Analizzando...</div>
                <div class="confidence-score" id="confidenceScore">Precisione: --</div>
                <div class="voice-breakdown" id="voiceBreakdown">
                    <div class="voice-score">
                        <div>🌬️ ARIA</div>
                        <div id="scoreAria">--%</div>
                    </div>
                    <div class="voice-score">
                        <div>💧 ACQUA</div>
                        <div id="scoreAcqua">--%</div>
                    </div>
                    <div class="voice-score">
                        <div>🌍 TERRA</div>
                        <div id="scoreTerra">--%</div>
                    </div>
                    <div class="voice-score">
                        <div>🔥 FUOCO</div>
                        <div id="scoreFuoco">--%</div>
                    </div>
                </div>
            </div>

            <div class="error-message" id="errorMessage"></div>
            <div class="success-message" id="successMessage"></div>
            <div class="warning-message" id="warningMessage"></div>
            
            <div class="processing-indicator" id="processingIndicator">
                <div class="spinner"></div>
                <div>Analizzando le frasi...</div>
            </div>

            <div class="debug-section">
                <div class="debug-title">🔍 Log di Debug</div>
                <div class="debug-log" id="debugLog">
                    Inizializzazione sistema...<br>
                </div>
            </div>

            <div class="phrase-results" id="phraseResults">
                <div class="phrases-summary" id="phrasesSummary">
                    <div class="summary-card">
                        <div class="summary-number" id="totalPhrases">0</div>
                        <div class="summary-label">Frasi Rilevate</div>
                    </div>
                    <div class="summary-card">
                        <div class="summary-number" id="dominantVoice">--</div>
                        <div class="summary-label">Voce Dominante</div>
                    </div>
                    <div class="summary-card">
                        <div class="summary-number" id="avgPhraseDuration">0.0s</div>
                        <div class="summary-label">Durata Media Frase</div>
                    </div>
                    <div class="summary-card">
                        <div class="summary-number" id="overallClarity">--</div>
                        <div class="summary-label">Chiarezza Generale</div>
                    </div>
                </div>

                <div class="phrase-info-grid" id="phraseInfoGrid"></div>

                <div class="chart-container">
                    <canvas id="volumeTrendChart"></canvas>
                </div>

                <div class="chart-container">
                    <canvas id="individualPhrasesChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // === VARIABILI GLOBALI ===
        let app = {
            logger: null,
            isRecording: false,
            currentAudioData: null,
            currentPhrases: [],
            isSpeaking: false,
            speechSynth: window.speechSynthesis,
            availableVoices: [],
            volumeTrendChart: null,
            individualPhrasesChart: null,
            mediaRecorder: null,
            recordingChunks: [],
            recordingStartTime: null,
            recordingTimer: null,
            // 🆕 Speech Recognition
            speechRecognition: null,
            recognizedPhrases: [],
            isRecognitionEnabled: false
        };

        // === FUNZIONI UTILITY ===
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const prefix = type === 'error' ? '❌' : type === 'success' ? '✅' : type === 'warning' ? '⚠️' : 'ℹ️';
            const logEntry = `${timestamp} ${prefix} ${message}<br>`;
            
            const logElement = document.getElementById('debugLog');
            if (logElement) {
                logElement.innerHTML += logEntry;
                logElement.scrollTop = logElement.scrollHeight;
            }
            
            console.log(`[Voice Break AI] ${message}`);
        }

        function showMessage(message, type = 'success') {
            const messageEl = document.getElementById(`${type}Message`);
            if (messageEl) {
                messageEl.textContent = `${type === 'error' ? '❌' : type === 'warning' ? '⚠️' : '✅'} ${message}`;
                messageEl.style.display = 'block';
                
                setTimeout(() => {
                    messageEl.style.display = 'none';
                }, type === 'error' ? 8000 : 5000);
            }
        }

        function showProcessing(show, message = 'Elaborazione in corso...') {
            const indicator = document.getElementById('processingIndicator');
            if (!indicator) return;
            
            if (show) {
                indicator.style.display = 'block';
                const messageEl = indicator.querySelector('div:last-child');
                if (messageEl) messageEl.textContent = message;
            } else {
                indicator.style.display = 'none';
            }
        }

        function updateRecordingTimer() {
            if (!app.recordingStartTime) return;
            
            const elapsed = (Date.now() - app.recordingStartTime) / 1000;
            const minutes = Math.floor(elapsed / 60);
            const seconds = Math.floor(elapsed % 60);
            
            document.getElementById('recordingTime').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // === FUNZIONI PRINCIPALI ===
        function generateSampleText(trend, phraseIndex = 0, recognizedText = null) {
            // 🆕 Se abbiamo il testo riconosciuto, usalo
            if (recognizedText && recognizedText.trim()) {
                return recognizedText.trim();
            }
            
            // 🆕 Frasi più generiche che simulano un discorso reale
            const genericPhrases = [
                "Oggi mi sento bene",
                "Penso che sia giusto così", 
                "La situazione mi sembra chiara",
                "Vorrei esprimere il mio punto di vista",
                "Secondo me dovremmo procedere",
                "È importante considerare questo aspetto",
                "Mi viene da dire che",
                "In questo momento provo",
                "Credo fermamente che",
                "La mia impressione è",
                "Quello che voglio dire è",
                "Mi sembra evidente che"
            ];
            
            // Prova prima con frasi generiche
            if (phraseIndex < genericPhrases.length) {
                return genericPhrases[phraseIndex];
            }
            
            // Fallback alle frasi originali basate sul trend
            const samples = {
                ascending: [
                    "La mia energia cresce gradualmente",
                    "Sento sempre più fiducia in me",
                    "Vedo nuove possibilità che si aprono"
                ],
                descending: [
                    "Ora mi sento più calmo e rilassato",
                    "La tensione si sta dissolvendo",
                    "Trovo finalmente la mia pace interiore"
                ],
                stable: [
                    "Sono centrato e presente in questo momento",
                    "Mantengo il mio equilibrio naturale",
                    "La stabilità è la mia forza principale"
                ],
                dynamic: [
                    "L'energia scorre liberamente in me",
                    "Sento il ritmo del cambiamento",
                    "La vita pulsa attraverso ogni mia parola"
                ]
            };
            
            const trendSamples = samples[trend] || samples.stable;
            return trendSamples[phraseIndex % trendSamples.length];
        }

        function detectPhrases(audioBuffer) {
            log(`Iniziando rilevamento frasi intelligente. Buffer length: ${audioBuffer.length}`);
            
            if (audioBuffer.length === 0) {
                log('Buffer audio vuoto!', 'error');
                return [];
            }
            
            const durationInSeconds = audioBuffer.length / 44100;
            log(`Durata totale audio: ${durationInSeconds.toFixed(1)}s`);
            
            // 🎯 RILEVAMENTO INTELLIGENTE DELLE FRASI
            const phrases = detectPhrasesFromAudio(audioBuffer, durationInSeconds);
            
            log(`Rilevate ${phrases.length} frasi con durate: ${phrases.map(p => p.duration.toFixed(1) + 's').join(', ')}`);
            return phrases;
        }

        // 🆕 ALGORITMO DI RILEVAMENTO FRASI BASATO SU PAUSE E VOLUME
        function detectPhrasesFromAudio(audioBuffer, totalDuration) {
            const sampleRate = 44100;
            const windowSize = 1024; // Finestra di analisi
            const hopSize = 512;     // Sovrapposizione
            
            // 1. Calcola l'energia (volume) in finestre temporali
            const energyWindows = [];
            for (let i = 0; i < audioBuffer.length - windowSize; i += hopSize) {
                let energy = 0;
                for (let j = 0; j < windowSize; j++) {
                    energy += Math.pow(audioBuffer[i + j] || 0, 2);
                }
                energyWindows.push({
                    energy: Math.sqrt(energy / windowSize),
                    timeStart: i / sampleRate,
                    timeEnd: (i + windowSize) / sampleRate
                });
            }
            
            // 2. Trova la soglia di silenzio (percentile basso dell'energia)
            const sortedEnergies = energyWindows.map(w => w.energy).sort((a, b) => a - b);
            const silenceThreshold = sortedEnergies[Math.floor(sortedEnergies.length * 0.2)] * 2; // 20° percentile * 2
            
            log(`Soglia silenzio calcolata: ${silenceThreshold.toFixed(4)}`);
            
            // 3. Identifica periodi di silenzio (pause)
            const silenceRegions = [];
            let silenceStart = null;
            
            for (let i = 0; i < energyWindows.length; i++) {
                const window = energyWindows[i];
                
                if (window.energy < silenceThreshold) {
                    // Inizio o continuazione del silenzio
                    if (silenceStart === null) {
                        silenceStart = window.timeStart;
                    }
                } else {
                    // Fine del silenzio
                    if (silenceStart !== null) {
                        const silenceDuration = window.timeStart - silenceStart;
                        // Solo pause significative (>200ms)
                        if (silenceDuration > 0.2) {
                            silenceRegions.push({
                                start: silenceStart,
                                end: window.timeStart,
                                duration: silenceDuration
                            });
                        }
                        silenceStart = null;
                    }
                }
            }
            
            log(`Rilevate ${silenceRegions.length} pause: ${silenceRegions.map(s => s.duration.toFixed(2) + 's').join(', ')}`);
            
            // 4. Segmenta in frasi usando le pause
            const phrases = [];
            let currentPhraseStart = 0;
            
            // Filtra solo le pause più significative per evitare oversegmentation
            const significantPauses = silenceRegions.filter(s => s.duration > 0.4); // >400ms
            
            for (let i = 0; i < significantPauses.length; i++) {
                const pause = significantPauses[i];
                const phraseEnd = pause.start;
                const phraseDuration = phraseEnd - currentPhraseStart;
                
                // Solo frasi di durata ragionevole (1-12 secondi)
                if (phraseDuration >= 1.0 && phraseDuration <= 12.0) {
                    phrases.push(createPhraseFromSegment(
                        audioBuffer, 
                        currentPhraseStart, 
                        phraseEnd, 
                        phrases.length,
                        sampleRate
                    ));
                }
                
                currentPhraseStart = pause.end;
            }
            
            // Aggiungi l'ultima frase se significativa
            const lastPhraseDuration = totalDuration - currentPhraseStart;
            if (lastPhraseDuration >= 1.0) {
                phrases.push(createPhraseFromSegment(
                    audioBuffer, 
                    currentPhraseStart, 
                    totalDuration, 
                    phrases.length,
                    sampleRate
                ));
            }
            
            // 5. Fallback se non troviamo abbastanza pause naturali
            if (phrases.length === 0) {
                log('Nessuna pausa naturale trovata, usando segmentazione temporale uniforme', 'warning');
                return createUniformPhrases(totalDuration);
            }
            
            // 6. Se abbiamo troppe frasi piccole, unisci quelle adiacenti
            return mergeTooShortPhrases(phrases);
        }

        // 🆕 Crea una frase da un segmento audio con testo riconosciuto
        function createPhraseFromSegment(audioBuffer, startTime, endTime, index, sampleRate) {
            const startSample = Math.floor(startTime * sampleRate);
            const endSample = Math.floor(endTime * sampleRate);
            const segment = audioBuffer.slice(startSample, endSample);
            
            // Analizza il trend del volume nel segmento
            const trend = analyzeTrendInSegment(segment);
            const avgVolume = calculateAverageVolume(segment);
            const volumeData = createVolumeProfile(segment, 20);
            
            // 🆕 Trova il testo corrispondente a questo segmento temporale
            const recognizedText = findRecognizedTextForSegment(startTime, endTime);
            
            return {
                index: index,
                duration: endTime - startTime,
                startTime: startTime,
                endTime: endTime,
                temporalAnalysis: {
                    trend: trend,
                    volumeChange: volumeData[volumeData.length - 1] - volumeData[0],
                    avgVolume: avgVolume,
                    volumeData: volumeData,
                    timeData: Array.from({length: 20}, (_, i) => i * 0.1)
                },
                features: {
                    avgVolume: avgVolume,
                    pitch: 150 + Math.random() * 100, // Placeholder
                    spectralEnergy: Math.random() * 0.8
                },
                recognizedText: recognizedText, // 🆕 Testo reale se disponibile
                confidence: recognizedText ? 0.9 : 0.6 // Più fiducia se abbiamo testo reale
            };
        }

        // 🆕 Trova il testo riconosciuto per un segmento temporale
        function findRecognizedTextForSegment(startTime, endTime) {
            if (!app.recognizedPhrases || app.recognizedPhrases.length === 0) {
                return null;
            }
            
            // Cerca frasi che cadono in questo intervallo temporale
            const segmentStart = startTime * 1000; // Converti in ms
            const segmentEnd = endTime * 1000;
            
            const matchingPhrases = app.recognizedPhrases.filter(phrase => {
                return phrase.timestamp >= segmentStart && phrase.timestamp <= segmentEnd;
            });
            
            if (matchingPhrases.length > 0) {
                // Combina tutte le frasi in questo segmento
                return matchingPhrases.map(p => p.text).join(' ').trim();
            }
            
            // Se nessuna corrispondenza esatta, prova a trovare la più vicina
            const closest = app.recognizedPhrases.reduce((closest, phrase) => {
                const currentDistance = Math.min(
                    Math.abs(phrase.timestamp - segmentStart),
                    Math.abs(phrase.timestamp - segmentEnd)
                );
                const closestDistance = Math.min(
                    Math.abs(closest.timestamp - segmentStart),
                    Math.abs(closest.timestamp - segmentEnd)
                );
                
                return currentDistance < closestDistance ? phrase : closest;
            }, app.recognizedPhrases[0]);
            
            // Solo se molto vicina (entro 2 secondi)
            const distance = Math.min(
                Math.abs(closest.timestamp - segmentStart),
                Math.abs(closest.timestamp - segmentEnd)
            );
            
            return distance < 2000 ? closest.text : null;
        }

        // 🆕 Analizza il trend di volume in un segmento
        function analyzeTrendInSegment(segment) {
            if (segment.length < 1000) return 'stable';
            
            const quarterSize = Math.floor(segment.length / 4);
            const firstQuarter = segment.slice(0, quarterSize);
            const lastQuarter = segment.slice(-quarterSize);
            
            const avgFirst = calculateAverageVolume(firstQuarter);
            const avgLast = calculateAverageVolume(lastQuarter);
            const difference = avgLast - avgFirst;
            
            // Calcola anche la variabilità per rilevare dinamismo
            const midQuarters = segment.slice(quarterSize, -quarterSize);
            const variability = calculateVolumeVariability(midQuarters);
            
            if (variability > 8) { // Molto variabile
                return 'dynamic';
            } else if (difference > 3) { // Crescente
                return 'ascending';
            } else if (difference < -3) { // Calante  
                return 'descending';
            } else { // Stabile
                return 'stable';
            }
        }

        // 🆕 Calcola volume medio di un segmento
        function calculateAverageVolume(segment) {
            if (segment.length === 0) return -30;
            
            let sum = 0;
            for (let i = 0; i < segment.length; i++) {
                sum += Math.pow(segment[i] || 0, 2);
            }
            const rms = Math.sqrt(sum / segment.length);
            return 20 * Math.log10(rms + 1e-10); // Converti in dB
        }

        // 🆕 Calcola variabilità del volume
        function calculateVolumeVariability(segment) {
            const windowSize = Math.floor(segment.length / 10);
            const volumes = [];
            
            for (let i = 0; i < segment.length - windowSize; i += windowSize) {
                const window = segment.slice(i, i + windowSize);
                volumes.push(calculateAverageVolume(window));
            }
            
            const mean = volumes.reduce((sum, v) => sum + v, 0) / volumes.length;
            const variance = volumes.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / volumes.length;
            return Math.sqrt(variance);
        }

        // 🆕 Crea profilo volume per la visualizzazione
        function createVolumeProfile(segment, numPoints) {
            const chunkSize = Math.floor(segment.length / numPoints);
            const profile = [];
            
            for (let i = 0; i < numPoints; i++) {
                const start = i * chunkSize;
                const end = Math.min(start + chunkSize, segment.length);
                const chunk = segment.slice(start, end);
                profile.push(calculateAverageVolume(chunk));
            }
            
            return profile;
        }

        // 🆕 Unisci frasi troppo corte
        function mergeTooShortPhrases(phrases) {
            const merged = [];
            let i = 0;
            
            while (i < phrases.length) {
                let currentPhrase = phrases[i];
                
                // Se la frase è troppo corta (<2s) e ce n'è un'altra dopo, uniscile
                while (currentPhrase.duration < 2.0 && i + 1 < phrases.length) {
                    const nextPhrase = phrases[i + 1];
                    currentPhrase = mergeAdjacentPhrases(currentPhrase, nextPhrase);
                    i++;
                }
                
                merged.push(currentPhrase);
                i++;
            }
            
            return merged;
        }

        // 🆕 Unisce due frasi adiacenti
        function mergeAdjacentPhrases(phrase1, phrase2) {
            const combinedDuration = phrase2.endTime - phrase1.startTime;
            const combinedVolumeData = [...phrase1.temporalAnalysis.volumeData, ...phrase2.temporalAnalysis.volumeData];
            
            return {
                ...phrase1,
                duration: combinedDuration,
                endTime: phrase2.endTime,
                temporalAnalysis: {
                    ...phrase1.temporalAnalysis,
                    trend: phrase1.temporalAnalysis.trend, // Mantieni il trend della prima
                    volumeData: combinedVolumeData.slice(0, 20), // Mantieni 20 punti
                    avgVolume: (phrase1.temporalAnalysis.avgVolume + phrase2.temporalAnalysis.avgVolume) / 2
                }
            };
        }

        // 🆕 Fallback: segmentazione uniforme se non si trovano pause
        function createUniformPhrases(totalDuration) {
            const targetPhraseDuration = 4.0; // 4 secondi per frase
            const numPhrases = Math.max(1, Math.floor(totalDuration / targetPhraseDuration));
            const actualPhraseDuration = totalDuration / numPhrases;
            
            const phrases = [];
            for (let i = 0; i < numPhrases; i++) {
                const startTime = i * actualPhraseDuration;
                const endTime = Math.min((i + 1) * actualPhraseDuration, totalDuration);
                
                phrases.push({
                    index: i,
                    duration: endTime - startTime,
                    startTime: startTime,
                    endTime: endTime,
                    temporalAnalysis: {
                        trend: ['ascending', 'descending', 'stable', 'dynamic'][i % 4],
                        volumeChange: (Math.random() - 0.5) * 10,
                        avgVolume: -30 + Math.random() * 15,
                        volumeData: Array.from({length: 20}, () => -35 + Math.random() * 20),
                        timeData: Array.from({length: 20}, (_, j) => j * 0.1)
                    },
                    features: {
                        avgVolume: -30 + Math.random() * 15,
                        pitch: 150 + Math.random() * 100,
                        spectralEnergy: Math.random() * 0.8
                    },
                    recognizedText: null,
                    confidence: 0.6 + Math.random() * 0.3
                });
            }
            
            return phrases;
        }

        function classifyVoice(phrases) {
            if (!phrases || phrases.length === 0) {
                return {
                    detectedVoice: 'UNKNOWN',
                    confidence: 0,
                    scores: { ARIA: 25, ACQUA: 25, TERRA: 25, FUOCO: 25 }
                };
            }
            
            // 🔧 FIX: Simulazione classificazione COERENTE
            const voices = ['ARIA', 'ACQUA', 'TERRA', 'FUOCO'];
            const baseScores = {};
            
            // Genera punteggi casuali ma realistici
            voices.forEach(voice => {
                baseScores[voice] = Math.random() * 100;
            });
            
            // 🎯 Trova la voce con punteggio più alto PRIMA della normalizzazione
            const detectedVoice = voices.reduce((a, b) => baseScores[a] > baseScores[b] ? a : b);
            
            // Normalizza i punteggi mantenendo le proporzioni
            const total = voices.reduce((sum, voice) => sum + baseScores[voice], 0);
            const scores = {};
            voices.forEach(voice => {
                scores[voice] = (baseScores[voice] / total) * 100;
            });
            
            // La confidence è sempre basata sulla voce dominante
            const confidence = scores[detectedVoice] / 100;
            
            log(`Voce rilevata: ${detectedVoice} (${(confidence * 100).toFixed(1)}%)`, 'success');
            
            // 🆕 DEBUG LOG per verificare coerenza
            log(`Punteggi: ARIA=${scores.ARIA.toFixed(1)}%, ACQUA=${scores.ACQUA.toFixed(1)}%, TERRA=${scores.TERRA.toFixed(1)}%, FUOCO=${scores.FUOCO.toFixed(1)}%`);
            
            return {
                detectedVoice,
                confidence,
                scores
            };
        }

        function speakText(text, phraseIndex = null) {
            if (!app.speechSynth) {
                log('Speech Synthesis non disponibile', 'error');
                return;
            }
            
            if (app.isSpeaking) {
                app.speechSynth.cancel();
                app.isSpeaking = false;
                
                // Reset pulsanti
                document.querySelectorAll('.speak-btn').forEach(btn => {
                    btn.classList.remove('speaking');
                    btn.innerHTML = '<span>🔊</span>Ascolta';
                });
                return;
            }
            
            const utterance = new SpeechSynthesisUtterance(text);
            
            // Configura TTS
            const rate = document.getElementById('speechRate')?.value || 1;
            const pitch = document.getElementById('speechPitch')?.value || 1;
            const volume = document.getElementById('speechVolume')?.value || 0.8;
            const voiceIndex = document.getElementById('speechVoice')?.value;
            
            utterance.rate = parseFloat(rate);
            utterance.pitch = parseFloat(pitch);
            utterance.volume = parseFloat(volume);
            
            if (voiceIndex && app.availableVoices[voiceIndex]) {
                utterance.voice = app.availableVoices[voiceIndex];
            }
            
            app.isSpeaking = true;
            
            if (phraseIndex !== null) {
                const btn = document.querySelector(`[data-phrase-index="${phraseIndex}"]`);
                if (btn) {
                    btn.classList.add('speaking');
                    btn.innerHTML = '<span>⏹️</span>Stop';
                }
            }
            
            utterance.onend = () => {
                app.isSpeaking = false;
                if (phraseIndex !== null) {
                    const btn = document.querySelector(`[data-phrase-index="${phraseIndex}"]`);
                    if (btn) {
                        btn.classList.remove('speaking');
                        btn.innerHTML = '<span>🔊</span>Ascolta';
                    }
                }
            };
            
            utterance.onerror = () => {
                app.isSpeaking = false;
                log('Errore TTS', 'error');
            };
            
            app.speechSynth.speak(utterance);
            log(`TTS: "${text}"`);
        }

        function createChart(phrases, chartId, title) {
            const ctx = document.getElementById(chartId);
            if (!ctx) return;
            
            const context = ctx.getContext('2d');
            
            if (chartId === 'volumeTrendChart' && app.volumeTrendChart) {
                app.volumeTrendChart.destroy();
            }
            if (chartId === 'individualPhrasesChart' && app.individualPhrasesChart) {
                app.individualPhrasesChart.destroy();
            }
            
            // 🎨 COLORI BASATI SUL TIPO DI VOCE
            const voiceColors = {
                ascending: '#4682B4',  // ARIA - Blu
                descending: '#008B8B', // ACQUA - Teal
                stable: '#8B4513',     // TERRA - Marrone
                dynamic: '#DC143C'     // FUOCO - Rosso
            };
            
            const datasets = [];
            // 🆕 Array per memorizzare le annotazioni delle frasi
            const phraseAnnotations = [];
            
            // 🆕 Calcola la durata totale per dimensionare correttamente il grafico
            let totalDuration = 0;
            if (phrases.length > 0) {
                totalDuration = Math.max(...phrases.map(p => p.endTime || (p.startTime + p.duration)));
            }
            
            // 🆕 Calcola spaziatura dinamica basata sulla durata totale
            const timeScale = Math.max(1, totalDuration / 10); // Minimo 1 secondo per unità
            
            phrases.forEach((phrase, index) => {
                if (!phrase.temporalAnalysis) return;
                
                // 🎯 Colore basato sul trend/voce
                const color = voiceColors[phrase.temporalAnalysis.trend];
                let data;
                
                if (chartId === 'volumeTrendChart') {
                    // 🆕 Timeline REALE basata su startTime/endTime
                    const realStartTime = phrase.startTime || (index * 2.5);
                    const realDuration = phrase.duration;
                    
                    data = phrase.temporalAnalysis.volumeData.map((volume, i) => ({
                        x: realStartTime + (i / (phrase.temporalAnalysis.volumeData.length - 1)) * realDuration,
                        y: volume
                    }));
                    
                    // 🆕 Aggiungi annotazione per la frase con posizionamento intelligente
                    const displayText = generateSampleText(phrase.temporalAnalysis.trend, index, phrase.recognizedText);
                    const midTime = realStartTime + realDuration / 2;
                    const maxVolume = Math.max(...phrase.temporalAnalysis.volumeData);
                    
                    phraseAnnotations.push({
                        type: 'label',
                        xValue: midTime,
                        yValue: maxVolume + 3, // Più spazio sopra
                        backgroundColor: color + '20',
                        borderColor: color,
                        borderWidth: 1,
                        borderRadius: 6,
                        color: '#333',
                        content: [`Frase ${index + 1}:`, `"${displayText.substring(0, 30)}${displayText.length > 30 ? '...' : ''}"`],
                        font: {
                            size: 9,
                            weight: 'bold'
                        },
                        padding: 6,
                        textAlign: 'center',
                        position: 'center'
                    });
                    
                } else {
                    // Secondo grafico - stessa logica temporale reale
                    const realStartTime = phrase.startTime || (index * 2.5);
                    const realDuration = phrase.duration;
                    
                    data = phrase.temporalAnalysis.volumeData.map((volume, i) => ({
                        x: realStartTime + (i / (phrase.temporalAnalysis.volumeData.length - 1)) * realDuration,
                        y: volume
                    }));
                }
                
                // 🎭 Emoji per identificare le voci
                const voiceEmojis = {
                    ascending: '🌬️ Aria',
                    descending: '💧 Acqua', 
                    stable: '🌍 Terra',
                    dynamic: '🔥 Fuoco'
                };
                
                datasets.push({
                    label: `${voiceEmojis[phrase.temporalAnalysis.trend]} - Frase ${phrase.index + 1}`,
                    data: data,
                    borderColor: color,
                    backgroundColor: color + '30',
                    borderWidth: 3,
                    fill: chartId === 'individualPhrasesChart',
                    tension: 0.3,
                    pointRadius: 4,
                    pointBackgroundColor: color,
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2
                });
            });
            
            // 🆕 Configurazione avanzata per scrolling orizzontale
            const chartConfig = {
                type: 'line',
                data: { datasets: datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: title,
                            font: { size: 16, weight: 'bold' }
                        },
                        legend: {
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                padding: 15,
                                font: { size: 12 }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    const timePoint = context[0].parsed.x;
                                    const matchingPhrase = phrases.find(p => 
                                        timePoint >= (p.startTime || 0) && 
                                        timePoint <= ((p.startTime || 0) + p.duration)
                                    );
                                    
                                    if (matchingPhrase) {
                                        const displayText = generateSampleText(
                                            matchingPhrase.temporalAnalysis.trend, 
                                            matchingPhrase.index, 
                                            matchingPhrase.recognizedText
                                        );
                                        return `Frase ${matchingPhrase.index + 1}: "${displayText}"`;
                                    }
                                    return `Tempo: ${timePoint.toFixed(1)}s`;
                                },
                                label: function(context) {
                                    return `Volume: ${context.parsed.y.toFixed(1)} dB`;
                                }
                            },
                            backgroundColor: 'rgba(0,0,0,0.8)',
                            titleColor: '#fff',
                            bodyColor: '#fff',
                            borderColor: '#333',
                            borderWidth: 1,
                            cornerRadius: 8,
                            displayColors: true,
                            titleFont: { size: 12, weight: 'bold' },
                            bodyFont: { size: 11 },
                            padding: 12
                        },
                        // 🆕 Plugin zoom per scroll orizzontale
                        zoom: {
                            pan: {
                                enabled: true,
                                mode: 'x',
                                threshold: 10
                            },
                            zoom: {
                                wheel: {
                                    enabled: true,
                                    speed: 0.1
                                },
                                pinch: {
                                    enabled: true
                                },
                                mode: 'x',
                                limits: {
                                    x: {min: 0, max: totalDuration + 2}
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Tempo (secondi) - Scorri per navigare →',
                                font: { size: 14, weight: 'bold' }
                            },
                            type: 'linear',
                            // 🆕 Configurazione per visualizzazione estesa
                            min: 0,
                            max: Math.min(totalDuration + 1, 12), // Mostra max 12s inizialmente
                            grid: {
                                color: 'rgba(0,0,0,0.1)'
                            },
                            ticks: {
                                stepSize: 1, // Tick ogni secondo
                                callback: function(value) {
                                    return value.toFixed(0) + 's';
                                }
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Volume (dB)',
                                font: { size: 14, weight: 'bold' }
                            },
                            suggestedMin: -35,
                            suggestedMax: chartId === 'volumeTrendChart' ? -5 : -5,
                            grid: {
                                color: 'rgba(0,0,0,0.1)'
                            }
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    // 🆕 Eventi per gestire scroll con mouse wheel
                    onHover: (event, elements, chart) => {
                        event.native.target.style.cursor = elements.length > 0 ? 'pointer' : 'default';
                    }
                }
            };
            
            const chart = new Chart(context, chartConfig);
            
            // 🆕 Aggiungi controlli scroll manuali
            addScrollControls(chart, chartId, totalDuration);
            
            // 🆕 Alternativa alle annotazioni: overlay manuale per frasi
            if (chartId === 'volumeTrendChart') {
                addPhraseOverlaysExtended(chart.canvas, phrases, chart, totalDuration);
            }
            
            
            // 🆕 Aggiungi pulsante fullscreen
            addFullscreenButton(chart, chartId);
            
            if (chartId === 'volumeTrendChart') {
                app.volumeTrendChart = chart;
            } else {
                app.individualPhrasesChart = chart;
            }
        }

        // 🆕 Overlay frasi esteso per timeline lunghe
        function addPhraseOverlaysExtended(canvas, phrases, chart, totalDuration) {

        // 🆕 Aggiungi controlli scroll ai grafici
        function addScrollControls(chart, chartId, totalDuration) {
            const container = chart.canvas.parentElement;
            
            // Rimuovi controlli esistenti
            const existingControls = container.querySelector('.chart-scroll-controls');
            if (existingControls) existingControls.remove();
            
            if (totalDuration <= 12) return; // Non serve scroll se tutto visibile
            
            const controls = document.createElement('div');
            controls.className = 'chart-scroll-controls';
            controls.style.cssText = `
                position: absolute;
                bottom: 10px;
                right: 10px;
                background: rgba(255,255,255,0.9);
                border-radius: 8px;
                padding: 8px;
                box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                display: flex;
                gap: 5px;
                z-index: 20;
            `;
            
            const scrollLeft = document.createElement('button');
            scrollLeft.innerHTML = '⬅️';
            scrollLeft.style.cssText = 'border: none; background: #667eea; color: white; padding: 5px 10px; border-radius: 4px; cursor: pointer;';
            
            const scrollRight = document.createElement('button');
            scrollRight.innerHTML = '➡️';
            scrollRight.style.cssText = 'border: none; background: #667eea; color: white; padding: 5px 10px; border-radius: 4px; cursor: pointer;';
            
            const resetView = document.createElement('button');
            resetView.innerHTML = '🔄';
            resetView.style.cssText = 'border: none; background: #6c757d; color: white; padding: 5px 10px; border-radius: 4px; cursor: pointer;';
            resetView.title = 'Reset vista';
            
            scrollLeft.addEventListener('click', () => {
                const currentMin = chart.scales.x.min;
                const newMin = Math.max(0, currentMin - 5);
                chart.scales.x.options.min = newMin;
                chart.scales.x.options.max = newMin + 12;
                chart.update('none');
            });
            
            scrollRight.addEventListener('click', () => {
                const currentMax = chart.scales.x.max;
                const newMax = Math.min(totalDuration + 1, currentMax + 5);
                chart.scales.x.options.max = newMax;
                chart.scales.x.options.min = newMax - 12;
                chart.update('none');
            });
            
            resetView.addEventListener('click', () => {
                chart.scales.x.options.min = 0;
                chart.scales.x.options.max = Math.min(totalDuration + 1, 12);
                chart.update('none');
            });
            
            controls.appendChild(scrollLeft);
            controls.appendChild(scrollRight);
            controls.appendChild(resetView);
            container.appendChild(controls);
        }

        // 🆕 Aggiungi indicatore timeline (mini-mappa)
        function addTimelineIndicator(chart, chartId, totalDuration) {
            const container = chart.canvas.parentElement;
            
            // Rimuovi indicatore esistente
            const existingIndicator = container.querySelector('.chart-timeline-indicator');
            if (existingIndicator) existingIndicator.remove();
            
            if (totalDuration <= 12) return; // Non serve se tutto è visibile
            
            const indicator = document.createElement('div');
            indicator.className = 'chart-timeline-indicator';
            
            const thumb = document.createElement('div');
            thumb.className = 'chart-timeline-thumb';
            
            // Calcola dimensioni del thumb
            const visibleRatio = Math.min(12 / totalDuration, 1);
            thumb.style.width = (visibleRatio * 100) + '%';
            
            indicator.appendChild(thumb);
            container.appendChild(indicator);
            
            // Aggiorna posizione thumb quando il grafico si sposta
            const updateThumbPosition = () => {
                const currentMin = chart.scales.x.min || 0;
                const startRatio = currentMin / totalDuration;
                thumb.style.left = (startRatio * 100) + '%';
            };
            
            // Listener per aggiornare la posizione
            chart.options.onAnimationComplete = updateThumbPosition;
            
            // Click su indicatore per navigare
            indicator.addEventListener('click', (e) => {
                const rect = indicator.getBoundingClientRect();
                const clickRatio = (e.clientX - rect.left) / rect.width;
                const targetTime = clickRatio * totalDuration;
                
                // Centra la vista sul punto cliccato
                const newMin = Math.max(0, targetTime - 6);
                const newMax = Math.min(totalDuration, targetTime + 6);
                
                chart.scales.x.options.min = newMin;
                chart.scales.x.options.max = newMax;
                chart.update('none');
                updateThumbPosition();
            });
            
            // Drag per scorrere
            let isDragging = false;
            thumb.addEventListener('mousedown', (e) => {
                isDragging = true;
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const rect = indicator.getBoundingClientRect();
                const dragRatio = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
                const targetTime = dragRatio * totalDuration;
                
                const newMin = Math.max(0, targetTime - 6);
                const newMax = Math.min(totalDuration, newMin + 12);
                
                chart.scales.x.options.min = newMin;
                chart.scales.x.options.max = newMax;
                chart.update('none');
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
        }

        // 🆕 Navigazione da tastiera
        function addKeyboardNavigation(chart, totalDuration) {
            const container = chart.canvas.parentElement;
            
            // Rendi il container focusable
            container.tabIndex = 0;
            container.style.outline = 'none';
            
            container.addEventListener('keydown', (e) => {
                if (!container.contains(document.activeElement)) return;
                
                const currentMin = chart.scales.x.min || 0;
                const currentMax = chart.scales.x.max || 12;
                const viewWidth = currentMax - currentMin;
                
                let newMin, newMax;
                
                switch(e.key) {
                    case 'ArrowLeft':
                        e.preventDefault();
                        newMin = Math.max(0, currentMin - 2);
                        newMax = newMin + viewWidth;
                        break;
                        
                    case 'ArrowRight':
                        e.preventDefault();
                        newMax = Math.min(totalDuration, currentMax + 2);
                        newMin = newMax - viewWidth;
                        break;
                        
                    case 'Home':
                        e.preventDefault();
                        newMin = 0;
                        newMax = Math.min(12, totalDuration);
                        break;
                        
                    case 'End':
                        e.preventDefault();
                        newMax = totalDuration;
                        newMin = Math.max(0, totalDuration - 12);
                        break;
                        
                    case '+':
                    case '=':
                        e.preventDefault();
                        // Zoom in
                        const zoomInWidth = viewWidth * 0.8;
                        const center = (currentMin + currentMax) / 2;
                        newMin = center - zoomInWidth / 2;
                        newMax = center + zoomInWidth / 2;
                        break;
                        
                    case '-':
                        e.preventDefault();
                        // Zoom out
                        const zoomOutWidth = Math.min(viewWidth * 1.25, totalDuration);
                        const centerOut = (currentMin + currentMax) / 2;
                        newMin = Math.max(0, centerOut - zoomOutWidth / 2);
                        newMax = Math.min(totalDuration, centerOut + zoomOutWidth / 2);
                        break;
                        
                    default:
                        return;
                }
                
                chart.scales.x.options.min = newMin;
                chart.scales.x.options.max = newMax;
                chart.update('none');
            });
            
            // Mostra suggerimenti controlli quando focused
            container.addEventListener('focus', () => {
                showNavigationHints(container);
            });
        }

        // 🆕 Mostra suggerimenti navigazione
        function showNavigationHints(container) {
            const existing = container.querySelector('.navigation-hints');
            if (existing) return;
            
            const hints = document.createElement('div');
            hints.className = 'navigation-hints';
            hints.style.cssText = `
                position: absolute;
                top: 10px;
                left: 10px;
                background: rgba(0,0,0,0.8);
                color: white;
                padding: 8px 12px;
                border-radius: 6px;
                font-size: 11px;
                z-index: 25;
                pointer-events: none;
                opacity: 0;
                transition: opacity 0.3s ease;
            `;
            
            hints.innerHTML = `
                <div><strong>⌨️ Controlli Tastiera:</strong></div>
                <div>← → : Scorri timeline</div>
                <div>+ - : Zoom in/out</div>
                <div>Home/End : Inizio/Fine</div>
            `;
            
            container.appendChild(hints);
            
            // Fade in
            setTimeout(() => hints.style.opacity = '1', 10);
            
            // Fade out dopo 3 secondi
            setTimeout(() => {
                hints.style.opacity = '0';
                setTimeout(() => hints.remove(), 300);
            }, 3000);
        }

        // 🆕 Aggiungi pulsante fullscreen per i grafici
        function addFullscreenButton(chart, chartId) {
            const container = chart.canvas.parentElement;
            
            const fullscreenBtn = document.createElement('button');
            fullscreenBtn.innerHTML = '⛶';
            fullscreenBtn.title = 'Visualizzazione a schermo intero';
            fullscreenBtn.style.cssText = `
                position: absolute;
                top: 10px;
                right: 10px;
                background: rgba(255,255,255,0.9);
                border: 1px solid #ddd;
                border-radius: 4px;
                padding: 8px 12px;
                cursor: pointer;
                font-size: 16px;
                z-index: 20;
                transition: all 0.3s ease;
            `;
            
            fullscreenBtn.addEventListener('click', () => {
                if (container.requestFullscreen) {
                    container.requestFullscreen();
                } else if (container.webkitRequestFullscreen) {
                    container.webkitRequestFullscreen();
                } else if (container.msRequestFullscreen) {
                    container.msRequestFullscreen();
                }
            });
            
            fullscreenBtn.addEventListener('mouseenter', () => {
                fullscreenBtn.style.background = 'rgba(102, 126, 234, 0.1)';
                fullscreenBtn.style.borderColor = '#667eea';
            });
            
            fullscreenBtn.addEventListener('mouseleave', () => {
                fullscreenBtn.style.background = 'rgba(255,255,255,0.9)';
                fullscreenBtn.style.borderColor = '#ddd';
            });
            
            container.appendChild(fullscreenBtn);
        }
            const container = canvas.parentElement;
            
            // Rimuovi overlay esistenti
            const existingOverlays = container.querySelectorAll('.phrase-overlay');
            existingOverlays.forEach(overlay => overlay.remove());
            
            phrases.forEach((phrase, index) => {
                const displayText = generateSampleText(phrase.temporalAnalysis.trend, index, phrase.recognizedText);
                const overlay = document.createElement('div');
                overlay.className = 'phrase-overlay';
                
                // 🆕 Posizionamento dinamico basato su timeline reale
                const realStartTime = phrase.startTime || (index * 2.5);
                const containerWidth = container.offsetWidth - 40; // Padding
                const timelineWidth = totalDuration;
                const relativePosition = (realStartTime / timelineWidth) * containerWidth;
                
                overlay.style.cssText = `
                    position: absolute;
                    background: rgba(255,255,255,0.95);
                    border: 2px solid ${getVoiceColor(phrase.temporalAnalysis.trend)};
                    border-radius: 8px;
                    padding: 8px 12px;
                    font-size: 11px;
                    font-weight: bold;
                    color: #333;
                    pointer-events: none;
                    z-index: 10;
                    max-width: 200px;
                    text-align: center;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
                    top: ${20 + (index % 3) * 65}px;
                    left: ${Math.min(relativePosition, containerWidth - 200)}px;
                `;
                
                overlay.innerHTML = `
                    <div style="color: ${getVoiceColor(phrase.temporalAnalysis.trend)}; font-size: 12px; margin-bottom: 4px;">
                        ${getVoiceEmoji(phrase.temporalAnalysis.trend)} Frase ${index + 1} (${phrase.duration.toFixed(1)}s)
                    </div>
                    <div style="font-style: italic; line-height: 1.2;">
                        "${displayText.substring(0, 35)}${displayText.length > 35 ? '...' : ''}"
                    </div>
                    ${phrase.recognizedText ? '' : '<div style="font-size: 9px; color: #999; margin-top: 2px;">⚠️ Simulato</div>'}
                `;
                
                container.style.position = 'relative';
                container.appendChild(overlay);
            });
        }

        // 🆕 Funzione per aggiungere overlay delle frasi
        function addPhraseOverlays(canvas, phrases, chart) {
            const container = canvas.parentElement;
            
            // Rimuovi overlay esistenti
            const existingOverlays = container.querySelectorAll('.phrase-overlay');
            existingOverlays.forEach(overlay => overlay.remove());
            
            phrases.forEach((phrase, index) => {
                // 🆕 Usa il testo appropriato per gli overlay
                const displayText = generateSampleText(phrase.temporalAnalysis.trend, index, phrase.recognizedText);
                const overlay = document.createElement('div');
                overlay.className = 'phrase-overlay';
                overlay.style.cssText = `
                    position: absolute;
                    background: rgba(255,255,255,0.95);
                    border: 2px solid ${getVoiceColor(phrase.temporalAnalysis.trend)};
                    border-radius: 8px;
                    padding: 8px 12px;
                    font-size: 11px;
                    font-weight: bold;
                    color: #333;
                    pointer-events: none;
                    z-index: 10;
                    max-width: 200px;
                    text-align: center;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
                    top: ${20 + (index * 60)}px;
                    left: ${50 + (index * 180)}px;
                `;
                
                overlay.innerHTML = `
                    <div style="color: ${getVoiceColor(phrase.temporalAnalysis.trend)}; font-size: 12px; margin-bottom: 4px;">
                        ${getVoiceEmoji(phrase.temporalAnalysis.trend)} Frase ${index + 1}
                    </div>
                    <div style="font-style: italic; line-height: 1.2;">
                        "${displayText}"
                    </div>
                    ${phrase.recognizedText ? '' : '<div style="font-size: 9px; color: #999; margin-top: 2px;">⚠️ Simulato</div>'}
                `;
                
                container.style.position = 'relative';
                container.appendChild(overlay);
            });
        }

        // 🆕 Funzioni helper per colori ed emoji
        function getVoiceColor(trend) {
            const colors = {
                ascending: '#4682B4',
                descending: '#008B8B',
                stable: '#8B4513',
                dynamic: '#DC143C'
            };
            return colors[trend] || '#666';
        }

        function getVoiceEmoji(trend) {
            const emojis = {
                ascending: '🌬️',
                descending: '💧',
                stable: '🌍',
                dynamic: '🔥'
            };
            return emojis[trend] || '🎤';
        }

        // === EVENT HANDLERS ===
        function testMicrophone() {
            log('Test microfono avviato...');
            
            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(stream => {
                    log('Microfono accessibile ✅', 'success');
                    showMessage('Microfono funziona correttamente!');
                    stream.getTracks().forEach(track => track.stop());
                })
                .catch(error => {
                    log(`Errore microfono: ${error.message}`, 'error');
                    showMessage('Errore accesso microfono. Controlla i permessi.', 'error');
                });
        }

        function startRecording() {
            log('Avvio registrazione...');
            
            navigator.mediaDevices.getUserMedia({ 
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true
                }
            })
                .then(stream => {
                    app.recordingChunks = [];
                    app.recognizedPhrases = []; // Reset frasi riconosciute
                    
                    app.mediaRecorder = new MediaRecorder(stream);
                    app.isRecording = true;
                    app.recordingStartTime = Date.now();
                    
                    // 🆕 Avvia riconoscimento vocale se supportato
                    startSpeechRecognition();
                    
                    // Aggiorna timer
                    app.recordingTimer = setInterval(updateRecordingTimer, 100);
                    
                    app.mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            app.recordingChunks.push(event.data);
                        }
                    };
                    
                    app.mediaRecorder.onstop = () => {
                        const audioBlob = new Blob(app.recordingChunks, { type: 'audio/wav' });
                        convertBlobToAudioData(audioBlob);
                        stream.getTracks().forEach(track => track.stop());
                        stopSpeechRecognition(); // Ferma riconoscimento
                    };
                    
                    app.mediaRecorder.start(100); // Raccoglie dati ogni 100ms
                    
                    log('Registrazione avviata', 'success');
                    
                    // 🆕 Messaggio differenziato in base al supporto Speech Recognition
                    if (app.isRecognitionEnabled) {
                        showMessage('Registrazione + Riconoscimento vocale attivi... Parla chiaramente!');
                    } else {
                        showMessage('Registrazione in corso... (Riconoscimento vocale non supportato - analisi solo audio)');
                    }
                    
                    // Aggiorna UI
                    document.getElementById('startRecording').disabled = true;
                    document.getElementById('stopRecording').disabled = false;
                    document.getElementById('startRecording').classList.add('recording');
                    
                    // Simula visualizzatore audio
                    animateAudioBars();
                })
                .catch(error => {
                    log(`Errore registrazione: ${error.message}`, 'error');
                    showMessage('Errore durante la registrazione. Controlla i permessi del microfono.', 'error');
                });
        }

        // 🆕 Avvia riconoscimento vocale
        function startSpeechRecognition() {
            // Controlla supporto Speech Recognition
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            
            if (!SpeechRecognition) {
                log('Speech Recognition non supportato in questo browser', 'warning');
                app.isRecognitionEnabled = false;
                return;
            }
            
            app.speechRecognition = new SpeechRecognition();
            app.speechRecognition.continuous = true;
            app.speechRecognition.interimResults = true;
            app.speechRecognition.lang = 'it-IT'; // Italiano
            
            app.speechRecognition.onstart = () => {
                app.isRecognitionEnabled = true;
                log('Riconoscimento vocale avviato', 'success');
            };
            
            app.speechRecognition.onresult = (event) => {
                let finalTranscript = '';
                
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const result = event.results[i];
                    if (result.isFinal) {
                        finalTranscript += result[0].transcript + ' ';
                    }
                }
                
                if (finalTranscript.trim()) {
                    app.recognizedPhrases.push({
                        text: finalTranscript.trim(),
                        timestamp: Date.now() - app.recordingStartTime,
                        confidence: event.results[event.results.length - 1][0].confidence || 0.8
                    });
                    
                    log(`Frase riconosciuta: "${finalTranscript.trim()}"`, 'success');
                }
            };
            
            app.speechRecognition.onerror = (event) => {
                log(`Errore riconoscimento vocale: ${event.error}`, 'warning');
            };
            
            app.speechRecognition.onend = () => {
                app.isRecognitionEnabled = false;
                log('Riconoscimento vocale terminato');
            };
            
            try {
                app.speechRecognition.start();
            } catch (error) {
                log(`Impossibile avviare riconoscimento vocale: ${error.message}`, 'warning');
                app.isRecognitionEnabled = false;
            }
        }

        // 🆕 Ferma riconoscimento vocale
        function stopSpeechRecognition() {
            if (app.speechRecognition && app.isRecognitionEnabled) {
                app.speechRecognition.stop();
                log(`Riconoscimento completato. Frasi catturate: ${app.recognizedPhrases.length}`);
            }
        }

        function stopRecording() {
            if (app.isRecording && app.mediaRecorder) {
                app.mediaRecorder.stop();
                app.isRecording = false;
                
                if (app.recordingTimer) {
                    clearInterval(app.recordingTimer);
                    app.recordingTimer = null;
                }
                
                log('Registrazione fermata', 'success');
                
                // Aggiorna UI
                document.getElementById('startRecording').disabled = false;
                document.getElementById('stopRecording').disabled = true;
                document.getElementById('startRecording').classList.remove('recording');
                
                // Ferma animazione audio bars
                stopAudioBarsAnimation();
            }
        }

        function convertBlobToAudioData(blob) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const arrayBuffer = e.target.result;
                
                // 🆕 PROCESSAMENTO REALE DELL'AUDIO invece di simulazione
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                audioContext.decodeAudioData(arrayBuffer)
                    .then(audioBuffer => {
                        // Ottieni il canale audio (mono)
                        const channelData = audioBuffer.getChannelData(0);
                        
                        // Converti in Float32Array per la nostra analisi
                        app.currentAudioData = new Float32Array(channelData.length);
                        for (let i = 0; i < channelData.length; i++) {
                            app.currentAudioData[i] = channelData[i];
                        }
                        
                        const duration = audioBuffer.duration;
                        
                        document.getElementById('analyzePhrases').disabled = false;
                        document.getElementById('autoDetectVoice').disabled = false;
                        
                        showMessage(`Audio processato: ${duration.toFixed(1)}s (${channelData.length} campioni)`);
                        log(`Audio REALE processato: ${duration.toFixed(1)}s, ${channelData.length} campioni`, 'success');
                    })
                    .catch(error => {
                        log(`Errore decodifica audio: ${error.message}`, 'error');
                        
                        // Fallback: simulazione migliorata basata sulla durata reale
                        const duration = (Date.now() - app.recordingStartTime) / 1000;
                        app.currentAudioData = generateRealisticAudioSimulation(duration);
                        
                        document.getElementById('analyzePhrases').disabled = false;
                        document.getElementById('autoDetectVoice').disabled = false;
                        
                        showMessage(`Audio simulato: ${duration.toFixed(1)}s (fallback)`);
                        log(`Fallback su simulazione audio: ${duration.toFixed(1)}s`, 'warning');
                    });
            };
            reader.readAsArrayBuffer(blob);
        }

        // 🆕 Genera simulazione audio più realistica
        function generateRealisticAudioSimulation(durationSeconds) {
            const sampleRate = 44100;
            const totalSamples = Math.floor(durationSeconds * sampleRate);
            const audioData = new Float32Array(totalSamples);
            
            // Simula un discorso con pause naturali
            const pauseProbability = 0.15; // 15% di possibilità di pausa per ogni 100ms
            let currentVolume = 0.1;
            let isInPause = false;
            let pauseCountdown = 0;
            
            for (let i = 0; i < totalSamples; i++) {
                const timePosition = i / sampleRate;
                
                // Ogni 100ms, decidi se iniziare/finire una pausa
                if (i % (sampleRate / 10) === 0) {
                    if (!isInPause && Math.random() < pauseProbability) {
                        isInPause = true;
                        pauseCountdown = Math.floor(0.3 * sampleRate + Math.random() * 0.8 * sampleRate); // Pause 0.3-1.1s
                    }
                }
                
                if (isInPause) {
                    currentVolume = 0.01; // Quasi silenzio
                    pauseCountdown--;
                    if (pauseCountdown <= 0) {
                        isInPause = false;
                    }
                } else {
                    // Volume normale con variazioni naturali
                    currentVolume = 0.05 + Math.random() * 0.15 + 0.05 * Math.sin(timePosition * 3);
                }
                
                // Genera rumore audio con il volume calcolato
                audioData[i] = (Math.random() - 0.5) * 2 * currentVolume;
            }
            
            log(`Generata simulazione audio realistica: ${durationSeconds.toFixed(1)}s con pause naturali`);
            return audioData;
        }

        function animateAudioBars() {
            if (!app.isRecording) return;
            
            const bars = document.querySelectorAll('.audio-bar');
            bars.forEach(bar => {
                const height = Math.random() * 50 + 5;
                bar.style.height = `${height}px`;
            });
            
            if (app.isRecording) {
                setTimeout(animateAudioBars, 100);
            }
        }

        function stopAudioBarsAnimation() {
            const bars = document.querySelectorAll('.audio-bar');
            bars.forEach(bar => {
                bar.style.height = '2px';
            });
        }

        function autoDetectVoice() {
            if (!app.currentAudioData) {
                showMessage('Nessun audio da analizzare. Registra prima un audio.', 'error');
                return;
            }
            
            log('Iniziando auto-rilevamento voce...');
            showProcessing(true, 'Analizzando automaticamente la voce...');
            
            setTimeout(() => {
                const phrases = detectPhrases(app.currentAudioData);
                const classification = classifyVoice(phrases);
                
                // Mostra risultati
                document.getElementById('autoDetectionResult').style.display = 'block';
                
                const voiceEmojis = { ARIA: '🌬️', ACQUA: '💧', TERRA: '🌍', FUOCO: '🔥' };
                document.getElementById('detectedVoice').textContent = 
                    `${voiceEmojis[classification.detectedVoice]} ${classification.detectedVoice}`;
                
                document.getElementById('confidenceScore').textContent = 
                    `Precisione: ${(classification.confidence * 100).toFixed(1)}%`;
                
                document.getElementById('scoreAria').textContent = `${classification.scores.ARIA.toFixed(1)}%`;
                document.getElementById('scoreAcqua').textContent = `${classification.scores.ACQUA.toFixed(1)}%`;
                document.getElementById('scoreTerra').textContent = `${classification.scores.TERRA.toFixed(1)}%`;
                document.getElementById('scoreFuoco').textContent = `${classification.scores.FUOCO.toFixed(1)}%`;
                
                showProcessing(false);
                showMessage(`Voce rilevata: ${classification.detectedVoice} con precisione ${(classification.confidence * 100).toFixed(1)}%`);
            }, 1500);
        }

        function analyzePhrases() {
            if (!app.currentAudioData) {
                showMessage('Nessun audio da analizzare. Registra o carica un file audio.', 'error');
                return;
            }
            
            log('Iniziando analisi frasi dettagliata...');
            showProcessing(true, 'Analizzando le frasi...');
            
            setTimeout(() => {
                const phrases = detectPhrases(app.currentAudioData);
                const classification = classifyVoice(phrases);
                
                if (phrases.length === 0) {
                    showMessage('Nessuna frase rilevata. Prova a registrare di nuovo.', 'error');
                    showProcessing(false);
                    return;
                }
                
                app.currentPhrases = phrases;
                
                // 🆕 GARANTISCE COERENZA tra auto-detection e summary
                
                // Aggiorna auto-detection result per coerenza
                const autoDetectionDiv = document.getElementById('autoDetectionResult');
                if (autoDetectionDiv) {
                    autoDetectionDiv.style.display = 'block';
                    
                    const voiceEmojis = { ARIA: '🌬️', ACQUA: '💧', TERRA: '🌍', FUOCO: '🔥' };
                    document.getElementById('detectedVoice').textContent = 
                        `${voiceEmojis[classification.detectedVoice]} ${classification.detectedVoice}`;
                    
                    document.getElementById('confidenceScore').textContent = 
                        `Precisione: ${(classification.confidence * 100).toFixed(1)}%`;
                    
                    document.getElementById('scoreAria').textContent = `${classification.scores.ARIA.toFixed(1)}%`;
                    document.getElementById('scoreAcqua').textContent = `${classification.scores.ACQUA.toFixed(1)}%`;
                    document.getElementById('scoreTerra').textContent = `${classification.scores.TERRA.toFixed(1)}%`;
                    document.getElementById('scoreFuoco').textContent = `${classification.scores.FUOCO.toFixed(1)}%`;
                }
                
                // Aggiorna summary con STESSA classificazione
                document.getElementById('phraseResults').style.display = 'block';
                document.getElementById('totalPhrases').textContent = phrases.length;
                
                // 🔥 CONSISTENCY FIX: Usa SEMPRE la stessa voce dominante
                document.getElementById('dominantVoice').textContent = `🎤 ${classification.detectedVoice}`;
                
                document.getElementById('avgPhraseDuration').textContent = 
                    `${(phrases.reduce((sum, p) => sum + p.duration, 0) / phrases.length).toFixed(1)}s`;
                document.getElementById('overallClarity').textContent = 
                    classification.confidence > 0.7 ? 'Alta' : classification.confidence > 0.5 ? 'Media' : 'Bassa';
                
                // Crea cards frasi
                const container = document.getElementById('phraseInfoGrid');
                container.innerHTML = '';
                
                const trendDescriptions = {
                    ascending: '📈 Crescente',
                    descending: '📉 Calante',
                    stable: '➡️ Stabile',
                    dynamic: '🎢 Dinamico'
                };
                
                phrases.forEach((phrase, index) => {
                    const card = document.createElement('div');
                    card.className = `phrase-card trend-${phrase.temporalAnalysis.trend}`;
                    
                    // 🆕 Usa il testo riconosciuto se disponibile, altrimenti genera sample
                    const displayText = generateSampleText(phrase.temporalAnalysis.trend, index, phrase.recognizedText);
                    
                    card.innerHTML = `
                        <div class="phrase-title">Frase ${phrase.index + 1}</div>
                        <div class="phrase-trend trend-${phrase.temporalAnalysis.trend}">
                            ${trendDescriptions[phrase.temporalAnalysis.trend]}
                        </div>
                        <div>Durata: ${phrase.duration.toFixed(1)}s</div>
                        <div>Cambio: ${phrase.temporalAnalysis.volumeChange > 0 ? '+' : ''}${phrase.temporalAnalysis.volumeChange.toFixed(1)}dB</div>
                        <div>Media: ${phrase.temporalAnalysis.avgVolume.toFixed(1)}dB</div>
                        <div style="margin-top: 8px; font-style: italic; color: #666; font-size: 12px;">
                            "${displayText}"
                        </div>
                        ${phrase.recognizedText ? '' : '<div style="font-size: 10px; color: #999; margin-top: 4px;">⚠️ Testo simulato - Speech-to-Text non implementato</div>'}
                        <div class="phrase-controls">
                            <button class="speak-btn" data-phrase-index="${index}">
                                <span>🔊</span>
                                Ascolta
                            </button>
                        </div>
                    `;
                    
                    const speakBtn = card.querySelector('.speak-btn');
                    speakBtn.addEventListener('click', () => speakText(displayText, index));
                    
                    container.appendChild(card);
                });
                
                // Crea grafici
                createChart(phrases, 'volumeTrendChart', '📈 Andamento Temporale delle Voci - Timeline Completa');
                createChart(phrases, 'individualPhrasesChart', '🎭 Sequenza delle Voci nel Tempo - Confronto Diretto');
                
                // Abilita TTS per tutte le frasi
                document.getElementById('speakAllPhrases').disabled = false;
                
                showProcessing(false);
                showMessage(`Analisi completata: ${phrases.length} frasi rilevate. Voce dominante: ${classification.detectedVoice}`);
                
                // 🆕 LOG FINALE per debug
                log(`Analisi completata. Coerenza verificata: Auto-detection e Summary mostrano entrambi ${classification.detectedVoice}`, 'success');
                
            }, 2000);
        }

        function speakAllPhrases() {
            if (app.isSpeaking) {
                app.speechSynth.cancel();
                app.isSpeaking = false;
                document.getElementById('speakAllPhrases').innerHTML = '<span>🎤</span>Leggi Tutte le Frasi';
                return;
            }
            
            if (app.currentPhrases.length === 0) return;
            
            app.isSpeaking = true;
            document.getElementById('speakAllPhrases').innerHTML = '<span>⏹️</span>Ferma Lettura';
            
            let currentIndex = 0;
            
            function speakNext() {
                if (currentIndex >= app.currentPhrases.length || !app.isSpeaking) {
                    app.isSpeaking = false;
                    document.getElementById('speakAllPhrases').innerHTML = '<span>🎤</span>Leggi Tutte le Frasi';
                    return;
                }
                
                const phrase = app.currentPhrases[currentIndex];
                const sampleText = generateSampleText(phrase.temporalAnalysis.trend);
                
                const utterance = new SpeechSynthesisUtterance(sampleText);
                
                // Configura TTS
                const rate = document.getElementById('speechRate')?.value || 1;
                const pitch = document.getElementById('speechPitch')?.value || 1;
                const volume = document.getElementById('speechVolume')?.value || 0.8;
                
                utterance.rate = parseFloat(rate);
                utterance.pitch = parseFloat(pitch);
                utterance.volume = parseFloat(volume);
                
                utterance.onend = () => {
                    currentIndex++;
                    setTimeout(speakNext, 500);
                };
                
                app.speechSynth.speak(utterance);
                log(`TTS: "${sampleText}" (Frase ${currentIndex + 1})`);
            }
            
            speakNext();
        }

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.type.startsWith('audio/')) {
                showMessage('Seleziona un file audio valido.', 'error');
                return;
            }
            
            log(`Caricamento file: ${file.name}`);
            showProcessing(true, 'Caricamento file audio...');
            
            const reader = new FileReader();
            reader.onload = function(e) {
                // Simula caricamento e conversione
                setTimeout(() => {
                    app.currentAudioData = new Float32Array(44100 * 5); // 5 secondi simulati
                    for (let i = 0; i < app.currentAudioData.length; i++) {
                        app.currentAudioData[i] = (Math.random() - 0.5) * 0.1;
                    }
                    
                    document.getElementById('analyzePhrases').disabled = false;
                    document.getElementById('autoDetectVoice').disabled = false;
                    
                    showProcessing(false);
                    showMessage(`File caricato: ${file.name} (5.0s)`);
                    log('File caricato con successo', 'success');
                }, 1000);
            };
            
            reader.onerror = () => {
                showProcessing(false);
                showMessage('Errore durante il caricamento del file.', 'error');
                log('Errore caricamento file', 'error');
            };
            
            reader.readAsArrayBuffer(file);
        }

        function selectVoice(voiceName) {
            document.querySelectorAll('.voice-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            const selectedCard = document.querySelector(`[data-voice="${voiceName}"]`);
            if (selectedCard) selectedCard.classList.add('selected');
            
            log(`Voce selezionata: ${voiceName}`, 'success');
        }

        function clearResults() {
            document.getElementById('phraseResults').style.display = 'none';
            document.getElementById('autoDetectionResult').style.display = 'none';
            document.getElementById('analyzePhrases').disabled = true;
            document.getElementById('autoDetectVoice').disabled = true;
            document.getElementById('speakAllPhrases').disabled = true;
            document.getElementById('recordingTime').textContent = '00:00';
            
            if (app.isSpeaking) {
                app.speechSynth.cancel();
                app.isSpeaking = false;
            }
            
            app.currentAudioData = null;
            app.currentPhrases = [];
            
            if (app.volumeTrendChart) {
                app.volumeTrendChart.destroy();
                app.volumeTrendChart = null;
            }
            
            if (app.individualPhrasesChart) {
                app.individualPhrasesChart.destroy();
                app.individualPhrasesChart = null;
            }
            
            // Reset file input
            document.getElementById('fileInput').value = '';
            
            document.getElementById('debugLog').innerHTML = 'Log pulito...<br>';
            log('Risultati puliti', 'success');
        }

        function setupTTS() {
            if (!app.speechSynth) {
                log('Speech Synthesis non disponibile', 'warning');
                return;
            }
            
            function loadVoices() {
                app.availableVoices = app.speechSynth.getVoices();
                const voiceSelect = document.getElementById('speechVoice');
                
                if (voiceSelect) {
                    voiceSelect.innerHTML = '<option value="">Default</option>';
                    
                    app.availableVoices.forEach((voice, index) => {
                        const option = document.createElement('option');
                        option.value = index;
                        option.textContent = `${voice.name} (${voice.lang})`;
                        voiceSelect.appendChild(option);
                    });
                    
                    log(`Caricate ${app.availableVoices.length} voci TTS`, 'success');
                }
            }
            
            if (app.speechSynth.getVoices().length > 0) {
                loadVoices();
            } else {
                app.speechSynth.addEventListener('voiceschanged', loadVoices);
            }
        }

        function setupAudioVisualizer() {
            const visualizer = document.getElementById('audioVisualizer');
            if (visualizer) {
                visualizer.innerHTML = '';
                for (let i = 0; i < 50; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'audio-bar';
                    bar.style.left = `${i * 4}px`;
                    bar.style.height = '2px';
                    visualizer.appendChild(bar);
                }
            }
        }

        // === INIZIALIZZAZIONE ===
        document.addEventListener('DOMContentLoaded', function() {
            log('Voice Break AI inizializzata!', 'success');
            
            // Setup event listeners
            document.getElementById('testMicrophone').addEventListener('click', testMicrophone);
            document.getElementById('startRecording').addEventListener('click', startRecording);
            document.getElementById('stopRecording').addEventListener('click', stopRecording);
            document.getElementById('autoDetectVoice').addEventListener('click', autoDetectVoice);
            document.getElementById('analyzePhrases').addEventListener('click', analyzePhrases);
            document.getElementById('clearResults').addEventListener('click', clearResults);
            document.getElementById('fileInput').addEventListener('change', handleFileUpload);
            document.getElementById('speakAllPhrases').addEventListener('click', speakAllPhrases);
            
            // Voice cards
            document.querySelectorAll('.voice-card').forEach(card => {
                card.addEventListener('click', () => selectVoice(card.dataset.voice));
            });
            
            // Setup componenti
            setupTTS();
            setupAudioVisualizer();
            
            // Controllo compatibilità browser
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                log('MediaDevices API non supportata', 'error');
                showMessage('Browser non compatibile. Usa Chrome o Firefox.', 'error');
                return;
            }
            
            if (typeof MediaRecorder === 'undefined') {
                log('MediaRecorder non supportato', 'error');
                showMessage('MediaRecorder non supportato. Aggiorna il browser.', 'error');
                return;
            }
            
            log('Browser compatibile ✅', 'success');
            log('Tutti i sistemi operativi. App pronta per l\'uso!', 'success');
        });
    </script>
</body>
</html>