<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Break AI - Analisi per Frasi</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .main-panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #e9ecef;
        }

        .control-section h3 {
            margin-bottom: 15px;
            color: #495057;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: center;
            width: 100%;
            margin-bottom: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn.recording {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            animation: pulse 1.5s infinite;
        }

        .btn.phrase-analysis {
            background: linear-gradient(45deg, #00b894, #00a085);
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .voice-selector {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .voice-card {
            padding: 15px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            text-align: center;
        }

        .voice-card.selected {
            border-color: #667eea;
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .voice-card.aria { background: linear-gradient(135deg, #74b9ff, #0984e3); color: white; }
        .voice-card.acqua { background: linear-gradient(135deg, #00b894, #00a085); color: white; }
        .voice-card.terra { background: linear-gradient(135deg, #fdcb6e, #e17055); color: white; }
        .voice-card.fuoco { background: linear-gradient(135deg, #fd79a8, #e84393); color: white; }

        .audio-visualizer {
            height: 60px;
            background: #f8f9fa;
            border-radius: 8px;
            margin: 15px 0;
            position: relative;
            overflow: hidden;
        }

        .audio-bar {
            position: absolute;
            bottom: 0;
            width: 3px;
            background: linear-gradient(to top, #667eea, #764ba2);
            transition: height 0.1s ease;
        }

        .timer-display {
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            color: #495057;
            font-family: monospace;
        }

        .phrase-results {
            margin-top: 30px;
            display: none;
        }

        .phrases-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .summary-card {
            background: white;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }

        .summary-number {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .summary-label {
            color: #6c757d;
            font-size: 0.9em;
        }

        .phrase-list {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
        }

        .phrase-item {
            display: flex;
            align-items: center;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 10px;
            border-left: 4px solid #667eea;
            background: #f8f9fa;
            transition: all 0.3s ease;
        }

        .phrase-item:hover {
            transform: translateX(5px);
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }

        .phrase-number {
            background: #667eea;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 15px;
        }

        .phrase-info {
            flex: 1;
        }

        .phrase-voice {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .phrase-details {
            font-size: 0.9em;
            color: #6c757d;
        }

        .phrase-aria { border-left-color: #74b9ff; }
        .phrase-aria .phrase-number { background: #74b9ff; }

        .phrase-acqua { border-left-color: #00b894; }
        .phrase-acqua .phrase-number { background: #00b894; }

        .phrase-terra { border-left-color: #fdcb6e; }
        .phrase-terra .phrase-number { background: #fdcb6e; }

        .phrase-fuoco { border-left-color: #fd79a8; }
        .phrase-fuoco .phrase-number { background: #fd79a8; }

        .chart-container {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            height: 500px;
        }

        .processing-indicator {
            display: none;
            text-align: center;
            margin: 20px 0;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            background: #ff6b6b;
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            display: none;
        }

        .success-message {
            background: #00b894;
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            display: none;
        }

        @media (max-width: 768px) {
            .controls-grid {
                grid-template-columns: 1fr;
            }
            
            .voice-selector {
                grid-template-columns: 1fr;
            }
            
            .phrases-summary {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>üé§ Voice Break AI</h1>
            <p>Analisi Vocale Basata su Frasi per le 4 Voci Elementali</p>
        </div>

        <!-- Pannello Principale -->
        <div class="main-panel">
            <!-- Controlli -->
            <div class="controls-grid">
                <!-- Registrazione -->
                <div class="control-section">
                    <h3>üéôÔ∏è Registrazione Audio</h3>
                    <button id="startRecording" class="btn">
                        <span>‚ñ∂Ô∏è</span>
                        Inizia Registrazione
                    </button>
                    <button id="stopRecording" class="btn" disabled>
                        <span>‚èπÔ∏è</span>
                        Stop Registrazione
                    </button>
                    <div class="audio-visualizer" id="audioVisualizer"></div>
                    <div class="timer-display" id="recordingTime">00:00</div>
                </div>

                <!-- Selezione Voce -->
                <div class="control-section">
                    <h3>üéØ Voce Target</h3>
                    <div class="voice-selector">
                        <div class="voice-card aria" data-voice="ARIA">
                            <div><strong>üå¨Ô∏è ARIA</strong></div>
                            <small>Apertura & Connessione</small>
                        </div>
                        <div class="voice-card acqua" data-voice="ACQUA">
                            <div><strong>üíß ACQUA</strong></div>
                            <small>Condivisione & Ascolto</small>
                        </div>
                        <div class="voice-card terra" data-voice="TERRA">
                            <div><strong>üåç TERRA</strong></div>
                            <small>Chiarezza & Struttura</small>
                        </div>
                        <div class="voice-card fuoco" data-voice="FUOCO">
                            <div><strong>üî• FUOCO</strong></div>
                            <small>Energia & Decisione</small>
                        </div>
                    </div>
                </div>

                <!-- Analisi -->
                <div class="control-section">
                    <h3>üî¨ Analisi Frasi</h3>
                    <button id="analyzePhrases" class="btn phrase-analysis" disabled>
                        <span>üéØ</span>
                        Analizza per Frasi
                    </button>
                    <button id="clearResults" class="btn">
                        <span>üîÑ</span>
                        Reset Risultati
                    </button>
                    <label class="btn" for="fileInput" style="margin-bottom: 0;">
                        <span>üìÅ</span>
                        Carica Audio
                    </label>
                    <input type="file" id="fileInput" accept="audio/*" style="display: none;">
                </div>
            </div>

            <!-- Indicatori -->
            <div class="error-message" id="errorMessage"></div>
            <div class="success-message" id="successMessage"></div>
            
            <div class="processing-indicator" id="processingIndicator">
                <div class="spinner"></div>
                <div>Analizzando le frasi...</div>
            </div>

            <!-- Risultati Analisi Frasi -->
            <div class="phrase-results" id="phraseResults">
                <!-- Summary Cards -->
                <div class="phrases-summary" id="phrasesSummary">
                    <div class="summary-card">
                        <div class="summary-number" id="totalPhrases">0</div>
                        <div class="summary-label">Frasi Rilevate</div>
                    </div>
                    <div class="summary-card">
                        <div class="summary-number" id="dominantVoice">--</div>
                        <div class="summary-label">Voce Dominante</div>
                    </div>
                    <div class="summary-card">
                        <div class="summary-number" id="avgPhraseDuration">0.0s</div>
                        <div class="summary-label">Durata Media Frase</div>
                    </div>
                    <div class="summary-card">
                        <div class="summary-number" id="overallClarity">--</div>
                        <div class="summary-label">Chiarezza Generale</div>
                    </div>
                </div>

                <!-- Grafico Frasi -->
                <div class="chart-container">
                    <canvas id="phrasesChart"></canvas>
                </div>

                <!-- Lista Frasi Dettagliata -->
                <div class="phrase-list">
                    <h3>üìù Dettaglio Frasi Analizzate</h3>
                    <div id="phrasesListContainer">
                        <!-- Popolato dinamicamente -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- JavaScript -->
    <script>
        // === PHRASE DETECTOR CLASS ===
        
        class PhraseDetector {
            constructor(sampleRate = 44100) {
                this.sampleRate = sampleRate;
                this.minPhraseLength = 0.8; // secondi
                this.maxPhraseLength = 8.0; // secondi
                this.silenceThreshold = 0.005;
                this.minPauseBetweenPhrases = 0.4;
                this.smoothingWindow = 0.1; // secondi
                this.energyHistory = [];
            }
            
            detectPhrases(audioBuffer) {
                console.log('üîç Rilevamento frasi dall\'audio...');
                
                // 1. Calcola energia smoothed
                const energySignal = this.calculateSmoothEnergy(audioBuffer);
                
                // 2. Rileva segmenti vocali
                const voiceSegments = this.detectVoiceActivity(energySignal);
                
                // 3. Raggruppa in frasi logiche
                const phrases = this.groupIntoLinguisticPhrases(voiceSegments, energySignal);
                
                // 4. Analizza caratteristiche di ogni frase
                const phrasesWithFeatures = this.analyzePhrasesFeatures(phrases, audioBuffer);
                
                console.log(`‚úÖ Rilevate ${phrasesWithFeatures.length} frasi`);
                return phrasesWithFeatures;
            }
            
            calculateSmoothEnergy(audioBuffer) {
                const windowSize = Math.floor(this.smoothingWindow * this.sampleRate);
                const energySignal = [];
                
                for (let i = 0; i < audioBuffer.length - windowSize; i += windowSize / 4) {
                    let energy = 0;
                    
                    for (let j = 0; j < windowSize && i + j < audioBuffer.length; j++) {
                        energy += audioBuffer[i + j] * audioBuffer[i + j];
                    }
                    
                    energy = Math.sqrt(energy / windowSize);
                    const smoothedEnergy = this.applySmoothingFilter(energy);
                    
                    energySignal.push({
                        time: i / this.sampleRate,
                        energy: smoothedEnergy,
                        sample: i
                    });
                }
                
                return energySignal;
            }
            
            applySmoothingFilter(currentEnergy) {
                this.energyHistory.push(currentEnergy);
                
                const historyLength = 5;
                if (this.energyHistory.length > historyLength) {
                    this.energyHistory.shift();
                }
                
                let weightedSum = 0;
                let totalWeight = 0;
                
                for (let i = 0; i < this.energyHistory.length; i++) {
                    const weight = (i + 1) / this.energyHistory.length;
                    weightedSum += this.energyHistory[i] * weight;
                    totalWeight += weight;
                }
                
                return weightedSum / totalWeight;
            }
            
            detectVoiceActivity(energySignal) {
                const segments = [];
                let currentSegment = null;
                
                const energies = energySignal.map(e => e.energy);
                const sortedEnergies = [...energies].sort((a, b) => a - b);
                const dynamicThreshold = sortedEnergies[Math.floor(sortedEnergies.length * 0.25)];
                const threshold = Math.max(this.silenceThreshold, dynamicThreshold);
                
                for (let i = 0; i < energySignal.length; i++) {
                    const point = energySignal[i];
                    const isVoice = point.energy > threshold;
                    
                    if (isVoice && !currentSegment) {
                        currentSegment = {
                            startTime: point.time,
                            startSample: point.sample,
                            energyPeaks: [point.energy]
                        };
                    } else if (isVoice && currentSegment) {
                        currentSegment.energyPeaks.push(point.energy);
                    } else if (!isVoice && currentSegment) {
                        currentSegment.endTime = point.time;
                        currentSegment.endSample = point.sample;
                        currentSegment.duration = currentSegment.endTime - currentSegment.startTime;
                        
                        if (currentSegment.duration >= this.minPhraseLength) {
                            segments.push(currentSegment);
                        }
                        
                        currentSegment = null;
                    }
                }
                
                if (currentSegment) {
                    const lastPoint = energySignal[energySignal.length - 1];
                    currentSegment.endTime = lastPoint.time;
                    currentSegment.endSample = lastPoint.sample;
                    currentSegment.duration = currentSegment.endTime - currentSegment.startTime;
                    
                    if (currentSegment.duration >= this.minPhraseLength) {
                        segments.push(currentSegment);
                    }
                }
                
                return segments;
            }
            
            groupIntoLinguisticPhrases(voiceSegments, energySignal) {
                if (voiceSegments.length === 0) return [];
                
                const phrases = [];
                let currentPhrase = [voiceSegments[0]];
                
                for (let i = 1; i < voiceSegments.length; i++) {
                    const prevSegment = voiceSegments[i - 1];
                    const currentSegment = voiceSegments[i];
                    
                    const pauseDuration = currentSegment.startTime - prevSegment.endTime;
                    const phraseStart = currentPhrase[0].startTime;
                    const phraseEnd = currentSegment.endTime;
                    const totalPhraseDuration = phraseEnd - phraseStart;
                    
                    const shouldMerge = this.shouldMergeSegments(
                        pauseDuration, 
                        totalPhraseDuration, 
                        prevSegment, 
                        currentSegment
                    );
                    
                    if (shouldMerge) {
                        currentPhrase.push(currentSegment);
                    } else {
                        phrases.push(this.createPhraseFromSegments(currentPhrase));
                        currentPhrase = [currentSegment];
                    }
                }
                
                if (currentPhrase.length > 0) {
                    phrases.push(this.createPhraseFromSegments(currentPhrase));
                }
                
                return phrases;
            }
            
            shouldMergeSegments(pauseDuration, totalPhraseDuration, prevSegment, currentSegment) {
                if (pauseDuration > this.minPauseBetweenPhrases * 2.5) return false;
                if (totalPhraseDuration > this.maxPhraseLength) return false;
                
                const prevEnergy = Math.max(...prevSegment.energyPeaks);
                const currentEnergy = Math.max(...currentSegment.energyPeaks);
                const energyRatio = Math.abs(currentEnergy - prevEnergy) / Math.max(prevEnergy, currentEnergy);
                
                if (energyRatio > 0.6 && pauseDuration > this.minPauseBetweenPhrases) return false;
                
                return true;
            }
            
            createPhraseFromSegments(segments) {
                const startTime = segments[0].startTime;
                const endTime = segments[segments.length - 1].endTime;
                const duration = endTime - startTime;
                
                const allEnergies = segments.flatMap(s => s.energyPeaks);
                const avgEnergy = allEnergies.reduce((sum, e) => sum + e, 0) / allEnergies.length;
                const maxEnergy = Math.max(...allEnergies);
                
                return {
                    id: `phrase_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
                    startTime: startTime,
                    endTime: endTime,
                    duration: duration,
                    segments: segments,
                    avgEnergy: avgEnergy,
                    maxEnergy: maxEnergy,
                    segmentCount: segments.length
                };
            }
            
            analyzePhrasesFeatures(phrases, audioBuffer) {
                return phrases.map((phrase, index) => {
                    const startSample = Math.floor(phrase.startTime * this.sampleRate);
                    const endSample = Math.floor(phrase.endTime * this.sampleRate);
                    const phraseAudio = audioBuffer.slice(startSample, endSample);
                    
                    const features = this.analyzePhraseAudio(phraseAudio, phrase);
                    
                    return {
                        ...phrase,
                        index: index,
                        features: features
                    };
                });
            }
            
            analyzePhraseAudio(phraseAudio, phrase) {
                // Volume RMS
                const rms = Math.sqrt(phraseAudio.reduce((sum, val) => sum + val * val, 0) / phraseAudio.length);
                const avgVolume = rms > 0 ? 20 * Math.log10(rms) : -60;
                
                // Pitch estimation
                const pitch = this.estimatePitch(phraseAudio);
                
                // Energia spettrale
                const spectralEnergy = this.calculateSpectralEnergy(phraseAudio);
                
                // Variazione volume
                const volumeVariation = this.calculateVolumeVariation(phraseAudio);
                
                // Articolazione
                const articulation = this.estimateArticulation(phraseAudio);
                
                return {
                    avgVolume: parseFloat(avgVolume.toFixed(2)),
                    pitch: parseFloat(pitch.toFixed(2)),
                    spectralEnergy: parseFloat(spectralEnergy.toFixed(2)),
                    volumeVariation: parseFloat(volumeVariation.toFixed(3)),
                    articulation: parseFloat(articulation.toFixed(3)),
                    intensity: phrase.maxEnergy,
                    clarity: articulation > 0.5 ? 'Alta' : articulation > 0.3 ? 'Media' : 'Bassa'
                };
            }
            
            estimatePitch(audio) {
                if (audio.length < 512) return 0;
                
                const fftSize = Math.min(1024, audio.length);
                const spectrum = this.simpleFFT(audio.slice(0, fftSize));
                
                let maxMagnitude = 0;
                let dominantFreq = 0;
                
                for (let i = 1; i < spectrum.length / 2; i++) {
                    const frequency = (i * this.sampleRate) / fftSize;
                    if (frequency > 80 && frequency < 400 && spectrum[i] > maxMagnitude) {
                        maxMagnitude = spectrum[i];
                        dominantFreq = frequency;
                    }
                }
                
                return dominantFreq;
            }
            
            calculateSpectralEnergy(audio) {
                if (audio.length < 256) return 0;
                
                const fftSize = Math.min(1024, audio.length);
                const spectrum = this.simpleFFT(audio.slice(0, fftSize));
                
                const lowBand = spectrum.slice(1, Math.floor(fftSize * 0.1)).reduce((sum, val) => sum + val, 0);
                const midBand = spectrum.slice(Math.floor(fftSize * 0.1), Math.floor(fftSize * 0.3)).reduce((sum, val) => sum + val, 0);
                const highBand = spectrum.slice(Math.floor(fftSize * 0.3), Math.floor(fftSize * 0.5)).reduce((sum, val) => sum + val, 0);
                
                const totalEnergy = lowBand + midBand + highBand;
                return totalEnergy > 0 ? (midBand + highBand) / totalEnergy : 0;
            }
            
            calculateVolumeVariation(audio) {
                const windowSize = Math.max(100, Math.floor(audio.length / 10));
                const volumes = [];
                
                for (let i = 0; i < audio.length - windowSize; i += windowSize) {
                    const window = audio.slice(i, i + windowSize);
                    const rms = Math.sqrt(window.reduce((sum, val) => sum + val * val, 0) / window.length);
                    volumes.push(rms);
                }
                
                if (volumes.length < 2) return 0;
                
                const mean = volumes.reduce((sum, val) => sum + val, 0) / volumes.length;
                const variance = volumes.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / volumes.length;
                
                return mean > 0 ? Math.sqrt(variance) / mean : 0;
            }
            
            estimateArticulation(audio) {
                let zeroCrossings = 0;
                for (let i = 1; i < audio.length; i++) {
                    if ((audio[i] >= 0) !== (audio[i - 1] >= 0)) {
                        zeroCrossings++;
                    }
                }
                
                const zcr = zeroCrossings / audio.length;
                return Math.min(1, zcr * 1000);
            }
            
            simpleFFT(signal) {
                const N = signal.length;
                const spectrum = new Array(N).fill(0);
                
                for (let k = 0; k < N / 2; k++) {
                    let real = 0, imag = 0;
                    
                    for (let n = 0; n < N; n++) {
                        const angle = -2 * Math.PI * k * n / N;
                        real += signal[n] * Math.cos(angle);
                        imag += signal[n] * Math.sin(angle);
                    }
                    
                    spectrum[k] = Math.sqrt(real * real + imag * imag);
                }
                
                return spectrum;
            }
        }

        // === VOICE ANALYZER CLASS ===
        
        class VoiceAnalyzer {
            constructor() {
                this.sampleRate = 44100;
                this.phraseDetector = new PhraseDetector(this.sampleRate);
                
                this.voiceProfiles = {
                    ARIA: {
                        volumeRange: [-30, -10],
                        pitchTrend: 'ascending',
                        energyLevel: 'medium-high',
                        articulation: 'clear'
                    },
                    ACQUA: {
                        volumeRange: [-40, -25],
                        pitchTrend: 'descending',
                        energyLevel: 'low',
                        articulation: 'soft'
                    },
                    TERRA: {
                        volumeRange: [-25, -15],
                        pitchTrend: 'stable',
                        energyLevel: 'medium',
                        articulation: 'precise'
                    },
                    FUOCO: {
                        volumeRange: [-15, -5],
                        pitchTrend: 'dynamic',
                        energyLevel: 'high',
                        articulation: 'intense'
                    }
                };
            }
            
            async analyzeAudioByPhrases(audioBuffer, duration) {
                console.log('üéØ Analizzando audio per frasi...');
                
                const phrases = this.phraseDetector.detectPhrases(audioBuffer);
                
                if (phrases.length === 0) {
                    throw new Error('Nessuna frase rilevata nell\'audio. Prova a parlare pi√π chiaramente.');
                }
                
                const phraseAnalysis = phrases.map(phrase => {
                    const voiceClassification = this.classifyPhraseVoice(phrase);
                    return {
                        ...phrase,
                        voiceType: voiceClassification.voice,
                        confidence: voiceClassification.confidence,
                        score: voiceClassification.score,
                        allScores: voiceClassification.allScores
                    };
                });
                
                const chartData = this.createPhraseChartData(phraseAnalysis);
                const summary = this.createPhrasesSummary(phraseAnalysis);
                
                return {
                    phrases: phraseAnalysis,
                    chartData: chartData,
                    summary: summary,
                    totalDuration: duration
                };
            }
            
            classifyPhraseVoice(phrase) {
                const features = phrase.features;
                const scores = {};
                
                scores.ARIA = this.calculateAriaScore(features);
                scores.ACQUA = this.calculateAcquaScore(features);
                scores.TERRA = this.calculateTerraScore(features);
                scores.FUOCO = this.calculateFuocoScore(features);
                
                const maxScore = Math.max(...Object.values(scores));
                const voice = Object.keys(scores).find(v => scores[v] === maxScore);
                
                return {
                    voice: voice,
                    score: maxScore,
                    confidence: maxScore > 0.7 ? 'Alta' : maxScore > 0.5 ? 'Media' : 'Bassa',
                    allScores: scores
                };
            }
            
            calculateAriaScore(features) {
                let score = 0;
                
                // Volume crescente medio-alto
                if (features.avgVolume >= -30 && features.avgVolume <= -10) score += 0.3;
                
                // Pitch medio-alto
                if (features.pitch >= 150 && features.pitch <= 250) score += 0.25;
                
                // Energia spettrale media-alta
                if (features.spectralEnergy >= 0.4 && features.spectralEnergy <= 0.7) score += 0.2;
                
                // Articolazione chiara
                if (features.articulation >= 0.4) score += 0.15;
                
                // Variazione dinamica
                if (features.volumeVariation >= 0.2 && features.volumeVariation <= 0.5) score += 0.1;
                
                return Math.min(1, score);
            }
            
            calculateAcquaScore(features) {
                let score = 0;
                
                // Volume basso
                if (features.avgVolume >= -40 && features.avgVolume <= -25) score += 0.35;
                
                // Pitch basso-medio
                if (features.pitch >= 100 && features.pitch <= 180) score += 0.25;
                
                // Energia spettrale bassa
                if (features.spectralEnergy <= 0.4) score += 0.2;
                
                // Articolazione morbida
                if (features.articulation <= 0.4) score += 0.1;
                
                // Poca variazione dinamica
                if (features.volumeVariation <= 0.3) score += 0.1;
                
                return Math.min(1, score);
            }
            
            calculateTerraScore(features) {
                let score = 0;
                
                // Volume medio-stabile
                if (features.avgVolume >= -25 && features.avgVolume <= -15) score += 0.3;
                
                // Pitch stabile medio
                if (features.pitch >= 140 && features.pitch <= 200) score += 0.25;
                
                // Energia spettrale media
                if (features.spectralEnergy >= 0.3 && features.spectralEnergy <= 0.6) score += 0.2;
                
                // Articolazione precisa
                if (features.articulation >= 0.5) score += 0.15;
                
                // Variazione controllata
                if (features.volumeVariation >= 0.1 && features.volumeVariation <= 0.3) score += 0.1;
                
                return Math.min(1, score);
            }
            
            calculateFuocoScore(features) {
                let score = 0;
                
                // Volume alto
                if (features.avgVolume >= -15) score += 0.35;
                
                // Pitch dinamico/alto
                if (features.pitch >= 180 || features.volumeVariation >= 0.4) score += 0.25;
                
                // Energia spettrale alta
                if (features.spectralEnergy >= 0.5) score += 0.2;
                
                // Articolazione intensa
                if (features.articulation >= 0.3) score += 0.1;
                
                // Alta variazione dinamica
                if (features.volumeVariation >= 0.3) score += 0.1;
                
                return Math.min(1, score);
            }
            
            createPhraseChartData(phraseAnalysis) {
                const voiceColors = {
                    ARIA: 'rgba(116, 185, 255, 0.8)',
                    ACQUA: 'rgba(0, 184, 148, 0.8)',
                    TERRA: 'rgba(253, 203, 110, 0.8)',
                    FUOCO: 'rgba(253, 121, 168, 0.8)'
                };
                
                const datasets = Object.keys(voiceColors).map(voice => {
                    const voicePhrases = phraseAnalysis.filter(p => p.voiceType === voice);
                    
                    return {
                        label: `${this.getVoiceEmoji(voice)} ${voice}`,
                        data: voicePhrases.map(phrase => ({
                            x: phrase.startTime,
                            y: phrase.features.avgVolume,
                            r: Math.max(6, Math.min(20, phrase.duration * 3)),
                            phrase: phrase
                        })),
                        backgroundColor: voiceColors[voice],
                        borderColor: voiceColors[voice].replace('0.8', '1'),
                        borderWidth: 2
                    };
                });
                
                return {
                    datasets: datasets.filter(d => d.data.length > 0)
                };
            }
            
            getVoiceEmoji(voice) {
                const emojis = {
                    ARIA: 'üå¨Ô∏è',
                    ACQUA: 'üíß',
                    TERRA: 'üåç',
                    FUOCO: 'üî•'
                };
                return emojis[voice] || 'üé§';
            }
            
            createPhrasesSummary(phraseAnalysis) {
                const totalPhrases = phraseAnalysis.length;
                
                // Conta frasi per voce
                const voiceCounts = {};
                phraseAnalysis.forEach(phrase => {
                    voiceCounts[phrase.voiceType] = (voiceCounts[phrase.voiceType] || 0) + 1;
                });
                
                // Trova voce dominante
                const dominantVoice = Object.keys(voiceCounts).reduce((a, b) => 
                    voiceCounts[a] > voiceCounts[b] ? a : b
                );
                
                // Durata media frase
                const avgDuration = phraseAnalysis.reduce((sum, p) => sum + p.duration, 0) / totalPhrases;
                
                // Chiarezza generale
                const avgClarity = phraseAnalysis.reduce((sum, p) => 
                    sum + (p.features.clarity === 'Alta' ? 3 : p.features.clarity === 'Media' ? 2 : 1), 0
                ) / totalPhrases;
                
                const clarityLabel = avgClarity >= 2.5 ? 'Alta' : avgClarity >= 1.5 ? 'Media' : 'Bassa';
                
                return {
                    totalPhrases: totalPhrases,
                    dominantVoice: dominantVoice,
                    avgDuration: avgDuration,
                    clarityLabel: clarityLabel,
                    voiceCounts: voiceCounts
                };
            }
        }

        // === MAIN APPLICATION CLASS ===
        
        class PhraseAnalysisApp {
            constructor() {
                this.analyzer = new VoiceAnalyzer();
                this.mediaRecorder = null;
                this.audioStream = null;
                this.recordedChunks = [];
                this.isRecording = false;
                this.recordingStartTime = null;
                this.currentAudioData = null;
                this.currentAudioDuration = null;
                this.phrasesChart = null;
                
                this.initializeApp();
            }
            
            initializeApp() {
                this.setupEventListeners();
                this.setupAudioVisualizer();
                console.log('‚úÖ Phrase Analysis App initialized');
            }
            
            setupEventListeners() {
                document.getElementById('startRecording').addEventListener('click', () => this.startRecording());
                document.getElementById('stopRecording').addEventListener('click', () => this.stopRecording());
                document.getElementById('analyzePhrases').addEventListener('click', () => this.analyzePhrases());
                document.getElementById('clearResults').addEventListener('click', () => this.clearResults());
                document.getElementById('fileInput').addEventListener('change', (e) => this.handleFileUpload(e));
                
                document.querySelectorAll('.voice-card').forEach(card => {
                    card.addEventListener('click', () => this.selectVoice(card.dataset.voice));
                });
            }
            
            setupAudioVisualizer() {
                const visualizer = document.getElementById('audioVisualizer');
                for (let i = 0; i < 50; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'audio-bar';
                    bar.style.left = `${i * 4}px`;
                    visualizer.appendChild(bar);
                }
            }
            
            async startRecording() {
                try {
                    this.audioStream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            sampleRate: 44100,
                            channelCount: 1,
                            echoCancellation: true,
                            noiseSuppression: true
                        } 
                    });
                    
                    this.mediaRecorder = new MediaRecorder(this.audioStream, {
                        mimeType: 'audio/webm;codecs=opus'
                    });
                    
                    this.recordedChunks = [];
                    
                    this.mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            this.recordedChunks.push(event.data);
                        }
                    };
                    
                    this.mediaRecorder.onstop = () => {
                        const blob = new Blob(this.recordedChunks, { type: 'audio/webm' });
                        this.processRecordedAudio(blob);
                    };
                    
                    this.mediaRecorder.start(100);
                    this.isRecording = true;
                    this.recordingStartTime = Date.now();
                    
                    this.updateRecordingUI(true);
                    this.startRealtimeVisualizer();
                    
                    console.log('üéôÔ∏è Recording started');
                } catch (error) {
                    console.error('‚ùå Error starting recording:', error);
                    this.showError('Errore durante l\'avvio della registrazione. Verifica i permessi del microfono.');
                }
            }
            
            stopRecording() {
                if (this.mediaRecorder && this.isRecording) {
                    this.mediaRecorder.stop();
                    this.audioStream.getTracks().forEach(track => track.stop());
                    this.isRecording = false;
                    
                    this.updateRecordingUI(false);
                    this.stopRealtimeVisualizer();
                    
                    console.log('‚èπÔ∏è Recording stopped');
                }
            }
            
            startRealtimeVisualizer() {
                if (!this.audioStream) return;
                
                const audioContext = new AudioContext();
                const source = audioContext.createMediaStreamSource(this.audioStream);
                const analyser = audioContext.createAnalyser();
                
                analyser.fftSize = 256;
                source.connect(analyser);
                
                const dataArray = new Uint8Array(analyser.frequencyBinCount);
                
                const updateVisualizer = () => {
                    if (!this.isRecording) return;
                    
                    analyser.getByteFrequencyData(dataArray);
                    this.updateAudioBars(dataArray);
                    
                    requestAnimationFrame(updateVisualizer);
                };
                
                updateVisualizer();
            }
            
            updateAudioBars(dataArray) {
                const bars = document.querySelectorAll('.audio-bar');
                const step = Math.floor(dataArray.length / bars.length);
                
                bars.forEach((bar, index) => {
                    const value = dataArray[index * step];
                    const height = (value / 255) * 100;
                    bar.style.height = `${height}%`;
                });
            }
            
            stopRealtimeVisualizer() {
                // Il visualizer si ferma automaticamente quando isRecording = false
            }
            
            updateRecordingUI(isRecording) {
                const startBtn = document.getElementById('startRecording');
                const stopBtn = document.getElementById('stopRecording');
                const analyzeBtn = document.getElementById('analyzePhrases');
                
                startBtn.disabled = isRecording;
                stopBtn.disabled = !isRecording;
                
                if (isRecording) {
                    startBtn.classList.add('recording');
                    this.startRecordingTimer();
                } else {
                    startBtn.classList.remove('recording');
                    this.stopRecordingTimer();
                    analyzeBtn.disabled = false;
                }
            }
            
            startRecordingTimer() {
                this.recordingTimer = setInterval(() => {
                    if (this.recordingStartTime) {
                        const elapsed = Date.now() - this.recordingStartTime;
                        const seconds = Math.floor(elapsed / 1000);
                        const minutes = Math.floor(seconds / 60);
                        const displaySeconds = seconds % 60;
                        
                        document.getElementById('recordingTime').textContent = 
                            `${minutes.toString().padStart(2, '0')}:${displaySeconds.toString().padStart(2, '0')}`;
                    }
                }, 1000);
            }
            
            stopRecordingTimer() {
                if (this.recordingTimer) {
                    clearInterval(this.recordingTimer);
                    this.recordingTimer = null;
                }
            }
            
            selectVoice(voiceName) {
                document.querySelectorAll('.voice-card').forEach(card => {
                    card.classList.remove('selected');
                });
                
                document.querySelector(`[data-voice="${voiceName}"]`).classList.add('selected');
                console.log(`üéØ Target voice selected: ${voiceName}`);
            }
            
            async processRecordedAudio(blob) {
                try {
                    const arrayBuffer = await blob.arrayBuffer();
                    const audioContext = new AudioContext();
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    
                    const audioData = audioBuffer.getChannelData(0);
                    const duration = audioBuffer.duration;
                    
                    this.currentAudioData = audioData;
                    this.currentAudioDuration = duration;
                    
                    document.getElementById('analyzePhrases').disabled = false;
                    this.showSuccess(`Audio registrato: ${duration.toFixed(1)}s`);
                    
                    console.log(`üìä Audio processed: ${duration.toFixed(2)}s`);
                    
                } catch (error) {
                    console.error('‚ùå Error processing audio:', error);
                    this.showError('Errore durante l\'elaborazione dell\'audio');
                }
            }
            
            async handleFileUpload(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                try {
                    this.showProcessing(true, 'Caricamento file audio...');
                    
                    const arrayBuffer = await file.arrayBuffer();
                    const audioContext = new AudioContext();
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    
                    const audioData = audioBuffer.getChannelData(0);
                    const duration = audioBuffer.duration;
                    
                    this.currentAudioData = audioData;
                    this.currentAudioDuration = duration;
                    
                    document.getElementById('analyzePhrases').disabled = false;
                    this.showSuccess(`File caricato: ${file.name} (${duration.toFixed(1)}s)`);
                    
                    console.log(`üìÅ File uploaded: ${file.name}`);
                    
                } catch (error) {
                    console.error('‚ùå Error uploading file:', error);
                    this.showError('Errore durante il caricamento del file. Assicurati che sia un file audio valido.');
                } finally {
                    this.showProcessing(false);
                }
            }
            
            async analyzePhrases() {
                if (!this.currentAudioData) {
                    this.showError('Nessun audio da analizzare. Registra o carica un file audio.');
                    return;
                }
                
                try {
                    this.showProcessing(true, 'Analizzando le frasi...');
                    
                    const result = await this.analyzer.analyzeAudioByPhrases(
                        this.currentAudioData, 
                        this.currentAudioDuration
                    );
                    
                    this.displayResults(result);
                    this.showSuccess(`Analisi completata: ${result.phrases.length} frasi rilevate`);
                    
                    console.log('‚úÖ Phrase analysis completed:', result);
                    
                } catch (error) {
                    console.error('‚ùå Error during phrase analysis:', error);
                    this.showError(error.message || 'Errore durante l\'analisi delle frasi');
                } finally {
                    this.showProcessing(false);
                }
            }
            
            displayResults(result) {
                // Mostra sezione risultati
                document.getElementById('phraseResults').style.display = 'block';
                
                // Aggiorna summary
                this.updateSummary(result.summary);
                
                // Crea grafico
                this.createPhrasesChart(result.chartData);
                
                // Mostra lista frasi
                this.displayPhrasesList(result.phrases);
            }
            
            updateSummary(summary) {
                document.getElementById('totalPhrases').textContent = summary.totalPhrases;
                document.getElementById('dominantVoice').textContent = 
                    `${this.analyzer.getVoiceEmoji(summary.dominantVoice)} ${summary.dominantVoice}`;
                document.getElementById('avgPhraseDuration').textContent = `${summary.avgDuration.toFixed(1)}s`;
                document.getElementById('overallClarity').textContent = summary.clarityLabel;
            }
            
            createPhrasesChart(chartData) {
                const ctx = document.getElementById('phrasesChart').getContext('2d');
                
                if (this.phrasesChart) {
                    this.phrasesChart.destroy();
                }
                
                this.phrasesChart = new Chart(ctx, {
                    type: 'bubble',
                    data: chartData,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Mappa delle Frasi per Voce Elementale',
                                font: { size: 16 }
                            },
                            legend: {
                                position: 'top'
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const phrase = context.raw.phrase;
                                        return [
                                            `Frase ${phrase.index + 1} - ${phrase.voiceType}`,
                                            `Durata: ${phrase.duration.toFixed(1)}s`,
                                            `Volume: ${phrase.features.avgVolume.toFixed(1)}dB`,
                                            `Pitch: ${phrase.features.pitch.toFixed(1)}Hz`,
                                            `Chiarezza: ${phrase.features.clarity}`,
                                            `Confidenza: ${phrase.confidence}`
                                        ];
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Tempo (secondi)'
                                },
                                type: 'linear'
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Volume Medio Frase (dB)'
                                }
                            }
                        }
                    }
                });
            }
            
            displayPhrasesList(phrases) {
                const container = document.getElementById('phrasesListContainer');
                container.innerHTML = '';
                
                phrases.forEach(phrase => {
                    const phraseItem = document.createElement('div');
                    phraseItem.className = `phrase-item phrase-${phrase.voiceType.toLowerCase()}`;
                    
                    phraseItem.innerHTML = `
                        <div class="phrase-number">${phrase.index + 1}</div>
                        <div class="phrase-info">
                            <div class="phrase-voice">
                                ${this.analyzer.getVoiceEmoji(phrase.voiceType)} ${phrase.voiceType} 
                                (${phrase.confidence})
                            </div>
                            <div class="phrase-details">
                                ‚è±Ô∏è ${phrase.startTime.toFixed(1)}s - ${phrase.endTime.toFixed(1)}s 
                                (${phrase.duration.toFixed(1)}s) ‚Ä¢ 
                                üîä ${phrase.features.avgVolume.toFixed(1)}dB ‚Ä¢ 
                                üéµ ${phrase.features.pitch.toFixed(0)}Hz ‚Ä¢ 
                                ‚ú® ${phrase.features.clarity}
                            </div>
                        </div>
                    `;
                    
                    container.appendChild(phraseItem);
                });
            }
            
            clearResults() {
                document.getElementById('phraseResults').style.display = 'none';
                document.getElementById('analyzePhrases').disabled = true;
                document.getElementById('recordingTime').textContent = '00:00';
                
                this.currentAudioData = null;
                this.currentAudioDuration = null;
                
                if (this.phrasesChart) {
                    this.phrasesChart.destroy();
                    this.phrasesChart = null;
                }
                
                // Reset visualizer bars
                document.querySelectorAll('.audio-bar').forEach(bar => {
                    bar.style.height = '0%';
                });
                
                console.log('üîÑ Results cleared');
            }
            
            showProcessing(show, message = 'Elaborazione in corso...') {
                const indicator = document.getElementById('processingIndicator');
                if (show) {
                    indicator.style.display = 'block';
                    indicator.querySelector('div:last-child').textContent = message;
                } else {
                    indicator.style.display = 'none';
                }
            }
            
            showError(message) {
                const errorDiv = document.getElementById('errorMessage');
                errorDiv.textContent = `‚ùå ${message}`;
                errorDiv.style.display = 'block';
                
                setTimeout(() => {
                    errorDiv.style.display = 'none';
                }, 5000);
            }
            
            showSuccess(message) {
                const successDiv = document.getElementById('successMessage');
                successDiv.textContent = `‚úÖ ${message}`;
                successDiv.style.display = 'block';
                
                setTimeout(() => {
                    successDiv.style.display = 'none';
                }, 3000);
            }
        }

        // === INIZIALIZZAZIONE APP ===
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üöÄ Initializing Phrase-Based Voice Analysis...');
            const app = new PhraseAnalysisApp();
        });
    </script>
</body>
</html>