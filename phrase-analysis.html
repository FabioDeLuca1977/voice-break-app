<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Break AI - Analisi per Frasi</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .main-panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #e9ecef;
        }

        .control-section h3 {
            margin-bottom: 15px;
            color: #495057;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: center;
            width: 100%;
            margin-bottom: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn.recording {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            animation: pulse 1.5s infinite;
        }

        .btn.phrase-analysis {
            background: linear-gradient(45deg, #00b894, #00a085);
        }

        .btn.auto-detect {
            background: linear-gradient(45deg, #6c5ce7, #a29bfe);
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .voice-selector {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .voice-card {
            padding: 15px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            text-align: center;
        }

        .voice-card.selected {
            border-color: #667eea;
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .voice-card.aria { background: linear-gradient(135deg, #87CEEB, #4682B4); color: white; }
        .voice-card.acqua { background: linear-gradient(135deg, #20B2AA, #008B8B); color: white; }
        .voice-card.terra { background: linear-gradient(135deg, #D2691E, #8B4513); color: white; }
        .voice-card.fuoco { background: linear-gradient(135deg, #FF6347, #DC143C); color: white; }

        .audio-visualizer {
            height: 60px;
            background: #f8f9fa;
            border-radius: 8px;
            margin: 15px 0;
            position: relative;
            overflow: hidden;
        }

        .audio-bar {
            position: absolute;
            bottom: 0;
            width: 3px;
            background: linear-gradient(to top, #667eea, #764ba2);
            transition: height 0.1s ease;
        }

        .timer-display {
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            color: #495057;
            font-family: monospace;
        }

        .auto-detection-result {
            background: linear-gradient(135deg, #6c5ce7, #a29bfe);
            color: white;
            padding: 20px;
            border-radius: 15px;
            margin: 15px 0;
            text-align: center;
            display: none;
        }

        .detected-voice {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .confidence-score {
            font-size: 1.2em;
            margin-bottom: 5px;
        }

        .voice-breakdown {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .voice-score {
            background: rgba(255, 255, 255, 0.2);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }

        .debug-section {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }

        .debug-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #495057;
        }

        .debug-log {
            color: #6c757d;
            line-height: 1.4;
        }

        .error-message, .success-message, .warning-message {
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            display: none;
        }

        .error-message { background: #ff6b6b; color: white; }
        .success-message { background: #00b894; color: white; }
        .warning-message { background: #ffa726; color: white; }

        .processing-indicator {
            display: none;
            text-align: center;
            margin: 20px 0;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .phrase-results {
            margin-top: 30px;
            display: none;
        }

        .phrases-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .summary-card {
            background: white;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }

        .summary-number {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .summary-label {
            color: #6c757d;
            font-size: 0.9em;
        }

        .phrase-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .phrase-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }

        .phrase-card.trend-ascending { border-left-color: #87CEEB; }
        .phrase-card.trend-descending { border-left-color: #20B2AA; }
        .phrase-card.trend-stable { border-left-color: #D2691E; }
        .phrase-card.trend-dynamic { border-left-color: #FF6347; }

        .phrase-title {
            font-weight: bold;
            color: #495057;
            margin-bottom: 5px;
        }

        .phrase-trend {
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .trend-ascending { color: #4682B4; }
        .trend-descending { color: #008B8B; }
        .trend-stable { color: #8B4513; }
        .trend-dynamic { color: #DC143C; }

        .phrase-controls {
            margin-top: 10px;
            display: flex;
            gap: 5px;
        }

        .speak-btn {
            background: linear-gradient(45deg, #6c757d, #495057);
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .speak-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 8px rgba(108, 117, 125, 0.4);
        }

        .speak-btn.speaking {
            background: linear-gradient(45deg, #28a745, #20c997);
            animation: pulse-speak 1s infinite;
        }

        @keyframes pulse-speak {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .tts-controls {
            background: #e9ecef;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
        }

        .tts-controls h4 {
            margin-bottom: 10px;
            color: #495057;
        }

        .voice-settings {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-bottom: 10px;
        }

        .voice-setting {
            display: flex;
            flex-direction: column;
        }

        .voice-setting label {
            font-size: 12px;
            color: #6c757d;
            margin-bottom: 3px;
        }

        .voice-setting input, .voice-setting select {
            padding: 5px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            font-size: 14px;
        }

        .chart-container {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            height: 500px;
            position: relative;
            overflow: hidden;
        }

        .chart-scroll-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(255,255,255,0.95);
            border-radius: 8px;
            padding: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: flex;
            gap: 5px;
            z-index: 20;
            backdrop-filter: blur(5px);
        }

        .chart-scroll-controls button {
            border: none;
            background: #667eea;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .chart-scroll-controls button:hover {
            background: #5a6fd8;
            transform: translateY(-1px);
        }

        .chart-scroll-controls button:active {
            transform: translateY(0);
        }

        .phrase-overlay {
            position: absolute;
            background: rgba(255,255,255,0.95);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 11px;
            font-weight: bold;
            color: #333;
            pointer-events: none;
            z-index: 10;
            max-width: 200px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
        }

        .phrase-overlay:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(0,0,0,0.25);
        }

        /* üÜï Indicatore di scroll per grafici lunghi */
        .chart-timeline-indicator {
            position: absolute;
            bottom: 45px;
            left: 20px;
            right: 80px;
            height: 6px;
            background: rgba(0,0,0,0.1);
            border-radius: 3px;
            z-index: 15;
            cursor: pointer;
        }

        .chart-timeline-thumb {
            height: 100%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border-radius: 3px;
            transition: all 0.3s ease;
            cursor: grab;
            position: relative;
        }

        .chart-timeline-thumb:hover {
            background: linear-gradient(45deg, #5a6fd8, #6a4190);
            transform: scaleY(1.2);
        }

        .chart-timeline-thumb:active {
            cursor: grabbing;
        }

        /* üÜï Hints navigazione */
        .navigation-hints {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 11px;
            z-index: 25;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            line-height: 1.4;
        }

        /* üÜï Pulsante fullscreen */
        .chart-fullscreen-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255,255,255,0.9);
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 16px;
            z-index: 20;
            transition: all 0.3s ease;
        }

        .chart-fullscreen-btn:hover {
            background: rgba(102, 126, 234, 0.1);
            border-color: #667eea;
            transform: scale(1.1);
        }

        /* üÜï Stili per fullscreen */
        .chart-container:fullscreen {
            height: 100vh;
            width: 100vw;
            padding: 40px;
            border-radius: 0;
        }

        .chart-container:-webkit-full-screen {
            height: 100vh;
            width: 100vw;
            padding: 40px;
            border-radius: 0;
        }

        /* üÜï Focus styles per navigazione keyboard */
        .chart-container:focus {
            outline: 2px solid #667eea;
            outline-offset: 2px;
        }

        @media (max-width: 768px) {
            .controls-grid {
                grid-template-columns: 1fr;
            }
            
            .voice-selector {
                grid-template-columns: 1fr;
            }
            
            .phrases-summary {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üé§ Voice Break AI</h1>
            <p>Analisi Vocale Basata su Frasi per le 4 Voci Elementali</p>
        </div>

        <div class="main-panel">
            <div class="controls-grid">
                <div class="control-section">
                    <h3>üéôÔ∏è Registrazione Audio</h3>
                    <button id="testMicrophone" class="btn">
                        <span>üîß</span>
                        Test Microfono
                    </button>
                    <button id="startRecording" class="btn">
                        <span>‚ñ∂Ô∏è</span>
                        Inizia Registrazione
                    </button>
                    <button id="stopRecording" class="btn" disabled>
                        <span>‚èπÔ∏è</span>
                        Stop Registrazione
                    </button>
                    <button id="autoDetectVoice" class="btn auto-detect" disabled>
                        <span>üéØ</span>
                        Auto-Rileva Voce
                    </button>
                    <div class="audio-visualizer" id="audioVisualizer"></div>
                    <div class="timer-display" id="recordingTime">00:00</div>
                </div>

                <div class="control-section">
                    <h3>üéØ Voce Target (Opzionale)</h3>
                    <div class="voice-selector">
                        <div class="voice-card aria" data-voice="ARIA">
                            <div><strong>üå¨Ô∏è ARIA</strong></div>
                            <small>Apertura & Connessione</small>
                        </div>
                        <div class="voice-card acqua" data-voice="ACQUA">
                            <div><strong>üíß ACQUA</strong></div>
                            <small>Condivisione & Ascolto</small>
                        </div>
                        <div class="voice-card terra" data-voice="TERRA">
                            <div><strong>üåç TERRA</strong></div>
                            <small>Chiarezza & Struttura</small>
                        </div>
                        <div class="voice-card fuoco" data-voice="FUOCO">
                            <div><strong>üî• FUOCO</strong></div>
                            <small>Energia & Decisione</small>
                        </div>
                    </div>
                    <small style="color: #6c757d;">üí° Puoi anche usare l'auto-rilevamento senza selezionare una voce</small>
                </div>

                <div class="control-section">
                    <h3>üî¨ Analisi Frasi</h3>
                    <button id="analyzePhrases" class="btn phrase-analysis" disabled>
                        <span>üéØ</span>
                        Analizza per Frasi
                    </button>
                    <button id="clearResults" class="btn">
                        <span>üîÑ</span>
                        Reset Risultati
                    </button>
                    <label class="btn" for="fileInput" style="margin-bottom: 0;">
                        <span>üìÅ</span>
                        Carica Audio
                    </label>
                    <input type="file" id="fileInput" accept="audio/*" style="display: none;">
                    
                    <div class="tts-controls">
                        <h4>üîä Text-to-Speech</h4>
                        <div class="voice-settings">
                            <div class="voice-setting">
                                <label>Velocit√†</label>
                                <input type="range" id="speechRate" min="0.5" max="2" step="0.1" value="1">
                            </div>
                            <div class="voice-setting">
                                <label>Pitch</label>
                                <input type="range" id="speechPitch" min="0.5" max="2" step="0.1" value="1">
                            </div>
                            <div class="voice-setting">
                                <label>Volume</label>
                                <input type="range" id="speechVolume" min="0" max="1" step="0.1" value="0.8">
                            </div>
                            <div class="voice-setting">
                                <label>Voce</label>
                                <select id="speechVoice">
                                    <option value="">Default</option>
                                </select>
                            </div>
                        </div>
                        <button id="speakAllPhrases" class="btn" disabled>
                            <span>üé§</span>
                            Leggi Tutte le Frasi
                        </button>
                    </div>
                </div>
            </div>

            <div class="auto-detection-result" id="autoDetectionResult">
                <div class="detected-voice" id="detectedVoice">üé§ Analizzando...</div>
                <div class="confidence-score" id="confidenceScore">Precisione: --</div>
                <div class="voice-breakdown" id="voiceBreakdown">
                    <div class="voice-score">
                        <div>üå¨Ô∏è ARIA</div>
                        <div id="scoreAria">--%</div>
                    </div>
                    <div class="voice-score">
                        <div>üíß ACQUA</div>
                        <div id="scoreAcqua">--%</div>
                    </div>
                    <div class="voice-score">
                        <div>üåç TERRA</div>
                        <div id="scoreTerra">--%</div>
                    </div>
                    <div class="voice-score">
                        <div>üî• FUOCO</div>
                        <div id="scoreFuoco">--%</div>
                    </div>
                </div>
            </div>

            <div class="error-message" id="errorMessage"></div>
            <div class="success-message" id="successMessage"></div>
            <div class="warning-message" id="warningMessage"></div>
            
            <div class="processing-indicator" id="processingIndicator">
                <div class="spinner"></div>
                <div>Analizzando le frasi...</div>
            </div>

            <div class="debug-section">
                <div class="debug-title">üîç Log di Debug</div>
                <div class="debug-log" id="debugLog">
                    Inizializzazione sistema...<br>
                </div>
            </div>

            <div class="phrase-results" id="phraseResults">
                <div class="phrases-summary" id="phrasesSummary">
                    <div class="summary-card">
                        <div class="summary-number" id="totalPhrases">0</div>
                        <div class="summary-label">Frasi Rilevate</div>
                    </div>
                    <div class="summary-card">
                        <div class="summary-number" id="dominantVoice">--</div>
                        <div class="summary-label">Voce Dominante</div>
                    </div>
                    <div class="summary-card">
                        <div class="summary-number" id="avgPhraseDuration">0.0s</div>
                        <div class="summary-label">Durata Media Frase</div>
                    </div>
                    <div class="summary-card">
                        <div class="summary-number" id="overallClarity">--</div>
                        <div class="summary-label">Chiarezza Generale</div>
                    </div>
                </div>

                <div class="phrase-info-grid" id="phraseInfoGrid"></div>

                <div class="chart-container">
                    <canvas id="volumeTrendChart"></canvas>
                </div>

                <div class="chart-container">
                    <canvas id="individualPhrasesChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // === VARIABILI GLOBALI ===
        let app = {
            logger: null,
            isRecording: false,
            currentAudioData: null,
            currentPhrases: [],
            isSpeaking: false,
            speechSynth: window.speechSynthesis,
            availableVoices: [],
            volumeTrendChart: null,
            individualPhrasesChart: null,
            mediaRecorder: null,
            recordingChunks: [],
            recordingStartTime: null,
            recordingTimer: null,
            // üÜï Speech Recognition
            speechRecognition: null,
            recognizedPhrases: [],
            isRecognitionEnabled: false
        };

        // === FUNZIONI UTILITY ===
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const prefix = type === 'error' ? '‚ùå' : type === 'success' ? '‚úÖ' : type === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
            const logEntry = `${timestamp} ${prefix} ${message}<br>`;
            
            const logElement = document.getElementById('debugLog');
            if (logElement) {
                logElement.innerHTML += logEntry;
                logElement.scrollTop = logElement.scrollHeight;
            }
            
            console.log(`[Voice Break AI] ${message}`);
        }

        function showMessage(message, type = 'success') {
            const messageEl = document.getElementById(`${type}Message`);
            if (messageEl) {
                messageEl.textContent = `${type === 'error' ? '‚ùå' : type === 'warning' ? '‚ö†Ô∏è' : '‚úÖ'} ${message}`;
                messageEl.style.display = 'block';
                
                setTimeout(() => {
                    messageEl.style.display = 'none';
                }, type === 'error' ? 8000 : 5000);
            }
        }

        function showProcessing(show, message = 'Elaborazione in corso...') {
            const indicator = document.getElementById('processingIndicator');
            if (!indicator) return;
            
            if (show) {
                indicator.style.display = 'block';
                const messageEl = indicator.querySelector('div:last-child');
                if (messageEl) messageEl.textContent = message;
            } else {
                indicator.style.display = 'none';
            }
        }

        function updateRecordingTimer() {
            if (!app.recordingStartTime) return;
            
            const elapsed = (Date.now() - app.recordingStartTime) / 1000;
            const minutes = Math.floor(elapsed / 60);
            const seconds = Math.floor(elapsed % 60);
            
            document.getElementById('recordingTime').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // === FUNZIONI PRINCIPALI ===
        function generateSampleText(trend, phraseIndex = 0, recognizedText = null) {
            // üÜï Se abbiamo il testo riconosciuto, usalo
            if (recognizedText && recognizedText.trim()) {
                return recognizedText.trim();
            }
            
            // üÜï Frasi pi√π generiche che simulano un discorso reale
            const genericPhrases = [
                "Oggi mi sento bene",
                "Penso che sia giusto cos√¨", 
                "La situazione mi sembra chiara",
                "Vorrei esprimere il mio punto di vista",
                "Secondo me dovremmo procedere",
                "√à importante considerare questo aspetto",
                "Mi viene da dire che",
                "In questo momento provo",
                "Credo fermamente che",
                "La mia impressione √®",
                "Quello che voglio dire √®",
                "Mi sembra evidente che"
            ];
            
            // Prova prima con frasi generiche
            if (phraseIndex < genericPhrases.length) {
                return genericPhrases[phraseIndex];
            }
            
            // Fallback alle frasi originali basate sul trend
            const samples = {
                ascending: [
                    "La mia energia cresce gradualmente",
                    "Sento sempre pi√π fiducia in me",
                    "Vedo nuove possibilit√† che si aprono"
                ],
                descending: [
                    "Ora mi sento pi√π calmo e rilassato",
                    "La tensione si sta dissolvendo",
                    "Trovo finalmente la mia pace interiore"
                ],
                stable: [
                    "Sono centrato e presente in questo momento",
                    "Mantengo il mio equilibrio naturale",
                    "La stabilit√† √® la mia forza principale"
                ],
                dynamic: [
                    "L'energia scorre liberamente in me",
                    "Sento il ritmo del cambiamento",
                    "La vita pulsa attraverso ogni mia parola"
                ]
            };
            
            const trendSamples = samples[trend] || samples.stable;
            return trendSamples[phraseIndex % trendSamples.length];
        }

        function detectPhrases(audioBuffer) {
            log(`Iniziando rilevamento frasi intelligente. Buffer length: ${audioBuffer.length}`);
            
            if (audioBuffer.length === 0) {
                log('Buffer audio vuoto!', 'error');
                return [];
            }
            
            const durationInSeconds = audioBuffer.length / 44100;
            log(`Durata totale audio: ${durationInSeconds.toFixed(1)}s`);
            
            // üéØ RILEVAMENTO INTELLIGENTE DELLE FRASI
            const phrases = detectPhrasesFromAudio(audioBuffer, durationInSeconds);
            
            log(`Rilevate ${phrases.length} frasi con durate: ${phrases.map(p => p.duration.toFixed(1) + 's').join(', ')}`);
            return phrases;
        }

        // üÜï ALGORITMO DI RILEVAMENTO FRASI BASATO SU PAUSE E VOLUME
        function detectPhrasesFromAudio(audioBuffer, totalDuration) {
            const sampleRate = 44100;
            const windowSize = 1024; // Finestra di analisi
            const hopSize = 512;     // Sovrapposizione
            
            // 1. Calcola l'energia (volume) in finestre temporali
            const energyWindows = [];
            for (let i = 0; i < audioBuffer.length - windowSize; i += hopSize) {
                let energy = 0;
                for (let j = 0; j < windowSize; j++) {
                    energy += Math.pow(audioBuffer[i + j] || 0, 2);
                }
                energyWindows.push({
                    energy: Math.sqrt(energy / windowSize),
                    timeStart: i / sampleRate,
                    timeEnd: (i + windowSize) / sampleRate
                });
            }
            
            // 2. Trova la soglia di silenzio (percentile basso dell'energia)
            const sortedEnergies = energyWindows.map(w => w.energy).sort((a, b) => a - b);
            const silenceThreshold = sortedEnergies[Math.floor(sortedEnergies.length * 0.2)] * 2; // 20¬∞ percentile * 2
            
            log(`Soglia silenzio calcolata: ${silenceThreshold.toFixed(4)}`);
            
            // 3. Identifica periodi di silenzio (pause)
            const silenceRegions = [];
            let silenceStart = null;
            
            for (let i = 0; i < energyWindows.length; i++) {
                const window = energyWindows[i];
                
                if (window.energy < silenceThreshold) {
                    // Inizio o continuazione del silenzio
                    if (silenceStart === null) {
                        silenceStart = window.timeStart;
                    }
                } else {
                    // Fine del silenzio
                    if (silenceStart !== null) {
                        const silenceDuration = window.timeStart - silenceStart;
                        // Solo pause significative (>200ms)
                        if (silenceDuration > 0.2) {
                            silenceRegions.push({
                                start: silenceStart,
                                end: window.timeStart,
                                duration: silenceDuration
                            });
                        }
                        silenceStart = null;
                    }
                }
            }
            
            log(`Rilevate ${silenceRegions.length} pause: ${silenceRegions.map(s => s.duration.toFixed(2) + 's').join(', ')}`);
            
            // 4. Segmenta in frasi usando le pause
            const phrases = [];
            let currentPhraseStart = 0;
            
            // Filtra solo le pause pi√π significative per evitare oversegmentation
            const significantPauses = silenceRegions.filter(s => s.duration > 0.4); // >400ms
            
            for (let i = 0; i < significantPauses.length; i++) {
                const pause = significantPauses[i];
                const phraseEnd = pause.start;
                const phraseDuration = phraseEnd - currentPhraseStart;
                
                // Solo frasi di durata ragionevole (1-12 secondi)
                if (phraseDuration >= 1.0 && phraseDuration <= 12.0) {
                    phrases.push(createPhraseFromSegment(
                        audioBuffer, 
                        currentPhraseStart, 
                        phraseEnd, 
                        phrases.length,
                        sampleRate
                    ));
                }
                
                currentPhraseStart = pause.end;
            }
            
            // Aggiungi l'ultima frase se significativa
            const lastPhraseDuration = totalDuration - currentPhraseStart;
            if (lastPhraseDuration >= 1.0) {
                phrases.push(createPhraseFromSegment(
                    audioBuffer, 
                    currentPhraseStart, 
                    totalDuration, 
                    phrases.length,
                    sampleRate
                ));
            }
            
            // 5. Fallback se non troviamo abbastanza pause naturali
            if (phrases.length === 0) {
                log('Nessuna pausa naturale trovata, usando segmentazione temporale uniforme', 'warning');
                return createUniformPhrases(totalDuration);
            }
            
            // 6. Se abbiamo troppe frasi piccole, unisci quelle adiacenti
            return mergeTooShortPhrases(phrases);
        }

        // üÜï Crea una frase da un segmento audio con testo riconosciuto
        function createPhraseFromSegment(audioBuffer, startTime, endTime, index, sampleRate) {
            const startSample = Math.floor(startTime * sampleRate);
            const endSample = Math.floor(endTime * sampleRate);
            const segment = audioBuffer.slice(startSample, endSample);
            
            // Analizza il trend del volume nel segmento
            const trend = analyzeTrendInSegment(segment);
            const avgVolume = calculateAverageVolume(segment);
            const volumeData = createVolumeProfile(segment, 20);
            
            // üÜï Trova il testo corrispondente a questo segmento temporale
            const recognizedText = findRecognizedTextForSegment(startTime, endTime);
            
            return {
                index: index,
                duration: endTime - startTime,
                startTime: startTime,
                endTime: endTime,
                temporalAnalysis: {
                    trend: trend,
                    volumeChange: volumeData[volumeData.length - 1] - volumeData[0],
                    avgVolume: avgVolume,
                    volumeData: volumeData,
                    timeData: Array.from({length: 20}, (_, i) => i * 0.1)
                },
                features: {
                    avgVolume: avgVolume,
                    pitch: 150 + Math.random() * 100, // Placeholder
                    spectralEnergy: Math.random() * 0.8
                },
                recognizedText: recognizedText, // üÜï Testo reale se disponibile
                confidence: recognizedText ? 0.9 : 0.6 // Pi√π fiducia se abbiamo testo reale
            };
        }

        // üÜï Trova il testo riconosciuto per un segmento temporale
        function findRecognizedTextForSegment(startTime, endTime) {
            if (!app.recognizedPhrases || app.recognizedPhrases.length === 0) {
                return null;
            }
            
            // Cerca frasi che cadono in questo intervallo temporale
            const segmentStart = startTime * 1000; // Converti in ms
            const segmentEnd = endTime * 1000;
            
            const matchingPhrases = app.recognizedPhrases.filter(phrase => {
                return phrase.timestamp >= segmentStart && phrase.timestamp <= segmentEnd;
            });
            
            if (matchingPhrases.length > 0) {
                // Combina tutte le frasi in questo segmento
                return matchingPhrases.map(p => p.text).join(' ').trim();
            }
            
            // Se nessuna corrispondenza esatta, prova a trovare la pi√π vicina
            const closest = app.recognizedPhrases.reduce((closest, phrase) => {
                const currentDistance = Math.min(
                    Math.abs(phrase.timestamp - segmentStart),
                    Math.abs(phrase.timestamp - segmentEnd)
                );
                const closestDistance = Math.min(
                    Math.abs(closest.timestamp - segmentStart),
                    Math.abs(closest.timestamp - segmentEnd)
                );
                
                return currentDistance < closestDistance ? phrase : closest;
            }, app.recognizedPhrases[0]);
            
            // Solo se molto vicina (entro 2 secondi)
            const distance = Math.min(
                Math.abs(closest.timestamp - segmentStart),
                Math.abs(closest.timestamp - segmentEnd)
            );
            
            return distance < 2000 ? closest.text : null;
        }

        // üÜï Analizza il trend di volume in un segmento
        function analyzeTrendInSegment(segment) {
            if (segment.length < 1000) return 'stable';
            
            const quarterSize = Math.floor(segment.length / 4);
            const firstQuarter = segment.slice(0, quarterSize);
            const lastQuarter = segment.slice(-quarterSize);
            
            const avgFirst = calculateAverageVolume(firstQuarter);
            const avgLast = calculateAverageVolume(lastQuarter);
            const difference = avgLast - avgFirst;
            
            // Calcola anche la variabilit√† per rilevare dinamismo
            const midQuarters = segment.slice(quarterSize, -quarterSize);
            const variability = calculateVolumeVariability(midQuarters);
            
            if (variability > 8) { // Molto variabile
                return 'dynamic';
            } else if (difference > 3) { // Crescente
                return 'ascending';
            } else if (difference < -3) { // Calante  
                return 'descending';
            } else { // Stabile
                return 'stable';
            }
        }

        // üÜï Calcola volume medio di un segmento
        function calculateAverageVolume(segment) {
            if (segment.length === 0) return -30;
            
            let sum = 0;
            for (let i = 0; i < segment.length; i++) {
                sum += Math.pow(segment[i] || 0, 2);
            }
            const rms = Math.sqrt(sum / segment.length);
            return 20 * Math.log10(rms + 1e-10); // Converti in dB
        }

        // üÜï Calcola variabilit√† del volume
        function calculateVolumeVariability(segment) {
            const windowSize = Math.floor(segment.length / 10);
            const volumes = [];
            
            for (let i = 0; i < segment.length - windowSize; i += windowSize) {
                const window = segment.slice(i, i + windowSize);
                volumes.push(calculateAverageVolume(window));
            }
            
            const mean = volumes.reduce((sum, v) => sum + v, 0) / volumes.length;
            const variance = volumes.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / volumes.length;
            return Math.sqrt(variance);
        }

        // üÜï Crea profilo volume per la visualizzazione
        function createVolumeProfile(segment, numPoints) {
            const chunkSize = Math.floor(segment.length / numPoints);
            const profile = [];
            
            for (let i = 0; i < numPoints; i++) {
                const start = i * chunkSize;
                const end = Math.min(start + chunkSize, segment.length);
                const chunk = segment.slice(start, end);
                profile.push(calculateAverageVolume(chunk));
            }
            
            return profile;
        }

        // üÜï Unisci frasi troppo corte
        function mergeTooShortPhrases(phrases) {
            const merged = [];
            let i = 0;
            
            while (i < phrases.length) {
                let currentPhrase = phrases[i];
                
                // Se la frase √® troppo corta (<2s) e ce n'√® un'altra dopo, uniscile
                while (currentPhrase.duration < 2.0 && i + 1 < phrases.length) {
                    const nextPhrase = phrases[i + 1];
                    currentPhrase = mergeAdjacentPhrases(currentPhrase, nextPhrase);
                    i++;
                }
                
                merged.push(currentPhrase);
                i++;
            }
            
            return merged;
        }

        // üÜï Unisce due frasi adiacenti
        function mergeAdjacentPhrases(phrase1, phrase2) {
            const combinedDuration = phrase2.endTime - phrase1.startTime;
            const combinedVolumeData = [...phrase1.temporalAnalysis.volumeData, ...phrase2.temporalAnalysis.volumeData];
            
            return {
                ...phrase1,
                duration: combinedDuration,
                endTime: phrase2.endTime,
                temporalAnalysis: {
                    ...phrase1.temporalAnalysis,
                    trend: phrase1.temporalAnalysis.trend, // Mantieni il trend della prima
                    volumeData: combinedVolumeData.slice(0, 20), // Mantieni 20 punti
                    avgVolume: (phrase1.temporalAnalysis.avgVolume + phrase2.temporalAnalysis.avgVolume) / 2
                }
            };
        }

        // üÜï Fallback: segmentazione uniforme se non si trovano pause
        function createUniformPhrases(totalDuration) {
            const targetPhraseDuration = 4.0; // 4 secondi per frase
            const numPhrases = Math.max(1, Math.floor(totalDuration / targetPhraseDuration));
            const actualPhraseDuration = totalDuration / numPhrases;
            
            const phrases = [];
            for (let i = 0; i < numPhrases; i++) {
                const startTime = i * actualPhraseDuration;
                const endTime = Math.min((i + 1) * actualPhraseDuration, totalDuration);
                
                phrases.push({
                    index: i,
                    duration: endTime - startTime,
                    startTime: startTime,
                    endTime: endTime,
                    temporalAnalysis: {
                        trend: ['ascending', 'descending', 'stable', 'dynamic'][i % 4],
                        volumeChange: (Math.random() - 0.5) * 10,
                        avgVolume: -30 + Math.random() * 15,
                        volumeData: Array.from({length: 20}, () => -35 + Math.random() * 20),
                        timeData: Array.from({length: 20}, (_, j) => j * 0.1)
                    },
                    features: {
                        avgVolume: -30 + Math.random() * 15,
                        pitch: 150 + Math.random() * 100,
                        spectralEnergy: Math.random() * 0.8
                    },
                    recognizedText: null,
                    confidence: 0.6 + Math.random() * 0.3
                });
            }
            
            return phrases;
        }

        function classifyVoice(phrases) {
            if (!phrases || phrases.length === 0) {
                return {
                    detectedVoice: 'UNKNOWN',
                    confidence: 0,
                    scores: { ARIA: 25, ACQUA: 25, TERRA: 25, FUOCO: 25 }
                };
            }
            
            // üîß FIX: Simulazione classificazione COERENTE
            const voices = ['ARIA', 'ACQUA', 'TERRA', 'FUOCO'];
            const baseScores = {};
            
            // Genera punteggi casuali ma realistici
            voices.forEach(voice => {
                baseScores[voice] = Math.random() * 100;
            });
            
            // üéØ Trova la voce con punteggio pi√π alto PRIMA della normalizzazione
            const detectedVoice = voices.reduce((a, b) => baseScores[a] > baseScores[b] ? a : b);
            
            // Normalizza i punteggi mantenendo le proporzioni
            const total = voices.reduce((sum, voice) => sum + baseScores[voice], 0);
            const scores = {};
            voices.forEach(voice => {
                scores[voice] = (baseScores[voice] / total) * 100;
            });
            
            // La confidence √® sempre basata sulla voce dominante
            const confidence = scores[detectedVoice] / 100;
            
            log(`Voce rilevata: ${detectedVoice} (${(confidence * 100).toFixed(1)}%)`, 'success');
            
            // üÜï DEBUG LOG per verificare coerenza
            log(`Punteggi: ARIA=${scores.ARIA.toFixed(1)}%, ACQUA=${scores.ACQUA.toFixed(1)}%, TERRA=${scores.TERRA.toFixed(1)}%, FUOCO=${scores.FUOCO.toFixed(1)}%`);
            
            return {
                detectedVoice,
                confidence,
                scores
            };
        }

        function speakText(text, phraseIndex = null) {
            if (!app.speechSynth) {
                log('Speech Synthesis non disponibile', 'error');
                return;
            }
            
            if (app.isSpeaking) {
                app.speechSynth.cancel();
                app.isSpeaking = false;
                
                // Reset pulsanti
                document.querySelectorAll('.speak-btn').forEach(btn => {
                    btn.classList.remove('speaking');
                    btn.innerHTML = '<span>üîä</span>Ascolta';
                });
                return;
            }
            
            const utterance = new SpeechSynthesisUtterance(text);
            
            // Configura TTS
            const rate = document.getElementById('speechRate')?.value || 1;
            const pitch = document.getElementById('speechPitch')?.value || 1;
            const volume = document.getElementById('speechVolume')?.value || 0.8;
            const voiceIndex = document.getElementById('speechVoice')?.value;
            
            utterance.rate = parseFloat(rate);
            utterance.pitch = parseFloat(pitch);
            utterance.volume = parseFloat(volume);
            
            if (voiceIndex && app.availableVoices[voiceIndex]) {
                utterance.voice = app.availableVoices[voiceIndex];
            }
            
            app.isSpeaking = true;
            
            if (phraseIndex !== null) {
                const btn = document.querySelector(`[data-phrase-index="${phraseIndex}"]`);
                if (btn) {
                    btn.classList.add('speaking');
                    btn.innerHTML = '<span>‚èπÔ∏è</span>Stop';
                }
            }
            
            utterance.onend = () => {
                app.isSpeaking = false;
                if (phraseIndex !== null) {
                    const btn = document.querySelector(`[data-phrase-index="${phraseIndex}"]`);
                    if (btn) {
                        btn.classList.remove('speaking');
                        btn.innerHTML = '<span>üîä</span>Ascolta';
                    }
                }
            };
            
            utterance.onerror = () => {
                app.isSpeaking = false;
                log('Errore TTS', 'error');
            };
            
            app.speechSynth.speak(utterance);
            log(`TTS: "${text}"`);
        }

        function createChart(phrases, chartId, title) {
            const ctx = document.getElementById(chartId);
            if (!ctx) return;
            
            const context = ctx.getContext('2d');
            
            if (chartId === 'volumeTrendChart' && app.volumeTrendChart) {
                app.volumeTrendChart.destroy();
            }
            if (chartId === 'individualPhrasesChart' && app.individualPhrasesChart) {
                app.individualPhrasesChart.destroy();
            }
            
            // üé® COLORI BASATI SUL TIPO DI VOCE
            const voiceColors = {
                ascending: '#4682B4',  // ARIA - Blu
                descending: '#008B8B', // ACQUA - Teal
                stable: '#8B4513',     // TERRA - Marrone
                dynamic: '#DC143C'     // FUOCO - Rosso
            };
            
            const datasets = [];
            // üÜï Array per memorizzare le annotazioni delle frasi
            const phraseAnnotations = [];
            
            // üÜï Calcola la durata totale per dimensionare correttamente il grafico
            let totalDuration = 0;
            if (phrases.length > 0) {
                totalDuration = Math.max(...phrases.map(p => p.endTime || (p.startTime + p.duration)));
            }
            
            // üÜï Calcola spaziatura dinamica basata sulla durata totale
            const timeScale = Math.max(1, totalDuration / 10); // Minimo 1 secondo per unit√†
            
            phrases.forEach((phrase, index) => {
                if (!phrase.temporalAnalysis) return;
                
                // üéØ Colore basato sul trend/voce
                const color = voiceColors[phrase.temporalAnalysis.trend];
                let data;
                
                if (chartId === 'volumeTrendChart') {
                    // üÜï Timeline REALE basata su startTime/endTime
                    const realStartTime = phrase.startTime || (index * 2.5);
                    const realDuration = phrase.duration;
                    
                    data = phrase.temporalAnalysis.volumeData.map((volume, i) => ({
                        x: realStartTime + (i / (phrase.temporalAnalysis.volumeData.length - 1)) * realDuration,
                        y: volume
                    }));
                    
                    // üÜï Aggiungi annotazione per la frase con posizionamento intelligente
                    const displayText = generateSampleText(phrase.temporalAnalysis.trend, index, phrase.recognizedText);
                    const midTime = realStartTime + realDuration / 2;
                    const maxVolume = Math.max(...phrase.temporalAnalysis.volumeData);
                    
                    phraseAnnotations.push({
                        type: 'label',
                        xValue: midTime,
                        yValue: maxVolume + 3, // Pi√π spazio sopra
                        backgroundColor: color + '20',
                        borderColor: color,
                        borderWidth: 1,
                        borderRadius: 6,
                        color: '#333',
                        content: [`Frase ${index + 1}:`, `"${displayText.substring(0, 30)}${displayText.length > 30 ? '...' : ''}"`],
                        font: {
                            size: 9,
                            weight: 'bold'
                        },
                        padding: 6,
                        textAlign: 'center',
                        position: 'center'
                    });
                    
                } else {
                    // Secondo grafico - stessa logica temporale reale
                    const realStartTime = phrase.startTime || (index * 2.5);
                    const realDuration = phrase.duration;
                    
                    data = phrase.temporalAnalysis.volumeData.map((volume, i) => ({
                        x: realStartTime + (i / (phrase.temporalAnalysis.volumeData.length - 1)) * realDuration,
                        y: volume
                    }));
                }
                
                // üé≠ Emoji per identificare le voci
                const voiceEmojis = {
                    ascending: 'üå¨Ô∏è Aria',
                    descending: 'üíß Acqua', 
                    stable: 'üåç Terra',
                    dynamic: 'üî• Fuoco'
                };
                
                datasets.push({
                    label: `${voiceEmojis[phrase.temporalAnalysis.trend]} - Frase ${phrase.index + 1}`,
                    data: data,
                    borderColor: color,
                    backgroundColor: color + '30',
                    borderWidth: 3,
                    fill: chartId === 'individualPhrasesChart',
                    tension: 0.3,
                    pointRadius: 4,
                    pointBackgroundColor: color,
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2
                });
            });
            
            // üÜï Configurazione avanzata per scrolling orizzontale
            const chartConfig = {
                type: 'line',
                data: { datasets: datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: title,
                            font: { size: 16, weight: 'bold' }
                        },
                        legend: {
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                padding: 15,
                                font: { size: 12 }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    const timePoint = context[0].parsed.x;
                                    const matchingPhrase = phrases.find(p => 
                                        timePoint >= (p.startTime || 0) && 
                                        timePoint <= ((p.startTime || 0) + p.duration)
                                    );
                                    
                                    if (matchingPhrase) {
                                        const displayText = generateSampleText(
                                            matchingPhrase.temporalAnalysis.trend, 
                                            matchingPhrase.index, 
                                            matchingPhrase.recognizedText
                                        );
                                        return `Frase ${matchingPhrase.index + 1}: "${displayText}"`;
                                    }
                                    return `Tempo: ${timePoint.toFixed(1)}s`;
                                },
                                label: function(context) {
                                    return `Volume: ${context.parsed.y.toFixed(1)} dB`;
                                }
                            },
                            backgroundColor: 'rgba(0,0,0,0.8)',
                            titleColor: '#fff',
                            bodyColor: '#fff',
                            borderColor: '#333',
                            borderWidth: 1,
                            cornerRadius: 8,
                            displayColors: true,
                            titleFont: { size: 12, weight: 'bold' },
                            bodyFont: { size: 11 },
                            padding: 12
                        },
                        // üÜï Plugin zoom per scroll orizzontale
                        zoom: {
                            pan: {
                                enabled: true,
                                mode: 'x',
                                threshold: 10
                            },
                            zoom: {
                                wheel: {
                                    enabled: true,
                                    speed: 0.1
                                },
                                pinch: {
                                    enabled: true
                                },
                                mode: 'x',
                                limits: {
                                    x: {min: 0, max: totalDuration + 2}
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Tempo (secondi) - Scorri per navigare ‚Üí',
                                font: { size: 14, weight: 'bold' }
                            },
                            type: 'linear',
                            // üÜï Configurazione per visualizzazione estesa
                            min: 0,
                            max: Math.min(totalDuration + 1, 12), // Mostra max 12s inizialmente
                            grid: {
                                color: 'rgba(0,0,0,0.1)'
                            },
                            ticks: {
                                stepSize: 1, // Tick ogni secondo
                                callback: function(value) {
                                    return value.toFixed(0) + 's';
                                }
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Volume (dB)',
                                font: { size: 14, weight: 'bold' }
                            },
                            suggestedMin: -35,
                            suggestedMax: chartId === 'volumeTrendChart' ? -5 : -5,
                            grid: {
                                color: 'rgba(0,0,0,0.1)'
                            }
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    // üÜï Eventi per gestire scroll con mouse wheel
                    onHover: (event, elements, chart) => {
                        event.native.target.style.cursor = elements.length > 0 ? 'pointer' : 'default';
                    }
                }
            };
            
            const chart = new Chart(context, chartConfig);
            
            // üÜï Aggiungi controlli scroll manuali
            addScrollControls(chart, chartId, totalDuration);
            
            // üÜï Alternativa alle annotazioni: overlay manuale per frasi
            if (chartId === 'volumeTrendChart') {
                addPhraseOverlaysExtended(chart.canvas, phrases, chart, totalDuration);
            }
            
            
            // üÜï Aggiungi pulsante fullscreen
            addFullscreenButton(chart, chartId);
            
            if (chartId === 'volumeTrendChart') {
                app.volumeTrendChart = chart;
            } else {
                app.individualPhrasesChart = chart;
            }
        }

        // üÜï Overlay frasi esteso per timeline lunghe
        function addPhraseOverlaysExtended(canvas, phrases, chart, totalDuration) {

        // üÜï Aggiungi controlli scroll ai grafici
        function addScrollControls(chart, chartId, totalDuration) {
            const container = chart.canvas.parentElement;
            
            // Rimuovi controlli esistenti
            const existingControls = container.querySelector('.chart-scroll-controls');
            if (existingControls) existingControls.remove();
            
            if (totalDuration <= 12) return; // Non serve scroll se tutto visibile
            
            const controls = document.createElement('div');
            controls.className = 'chart-scroll-controls';
            controls.style.cssText = `
                position: absolute;
                bottom: 10px;
                right: 10px;
                background: rgba(255,255,255,0.9);
                border-radius: 8px;
                padding: 8px;
                box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                display: flex;
                gap: 5px;
                z-index: 20;
            `;
            
            const scrollLeft = document.createElement('button');
            scrollLeft.innerHTML = '‚¨ÖÔ∏è';
            scrollLeft.style.cssText = 'border: none; background: #667eea; color: white; padding: 5px 10px; border-radius: 4px; cursor: pointer;';
            
            const scrollRight = document.createElement('button');
            scrollRight.innerHTML = '‚û°Ô∏è';
            scrollRight.style.cssText = 'border: none; background: #667eea; color: white; padding: 5px 10px; border-radius: 4px; cursor: pointer;';
            
            const resetView = document.createElement('button');
            resetView.innerHTML = 'üîÑ';
            resetView.style.cssText = 'border: none; background: #6c757d; color: white; padding: 5px 10px; border-radius: 4px; cursor: pointer;';
            resetView.title = 'Reset vista';
            
            scrollLeft.addEventListener('click', () => {
                const currentMin = chart.scales.x.min;
                const newMin = Math.max(0, currentMin - 5);
                chart.scales.x.options.min = newMin;
                chart.scales.x.options.max = newMin + 12;
                chart.update('none');
            });
            
            scrollRight.addEventListener('click', () => {
                const currentMax = chart.scales.x.max;
                const newMax = Math.min(totalDuration + 1, currentMax + 5);
                chart.scales.x.options.max = newMax;
                chart.scales.x.options.min = newMax - 12;
                chart.update('none');
            });
            
            resetView.addEventListener('click', () => {
                chart.scales.x.options.min = 0;
                chart.scales.x.options.max = Math.min(totalDuration + 1, 12);
                chart.update('none');
            });
            
            controls.appendChild(scrollLeft);
            controls.appendChild(scrollRight);
            controls.appendChild(resetView);
            container.appendChild(controls);
        }

        // üÜï Aggiungi indicatore timeline (mini-mappa)
        function addTimelineIndicator(chart, chartId, totalDuration) {
            const container = chart.canvas.parentElement;
            
            // Rimuovi indicatore esistente
            const existingIndicator = container.querySelector('.chart-timeline-indicator');
            if (existingIndicator) existingIndicator.remove();
            
            if (totalDuration <= 12) return; // Non serve se tutto √® visibile
            
            const indicator = document.createElement('div');
            indicator.className = 'chart-timeline-indicator';
            
            const thumb = document.createElement('div');
            thumb.className = 'chart-timeline-thumb';
            
            // Calcola dimensioni del thumb
            const visibleRatio = Math.min(12 / totalDuration, 1);
            thumb.style.width = (visibleRatio * 100) + '%';
            
            indicator.appendChild(thumb);
            container.appendChild(indicator);
            
            // Aggiorna posizione thumb quando il grafico si sposta
            const updateThumbPosition = () => {
                const currentMin = chart.scales.x.min || 0;
                const startRatio = currentMin / totalDuration;
                thumb.style.left = (startRatio * 100) + '%';
            };
            
            // Listener per aggiornare la posizione
            chart.options.onAnimationComplete = updateThumbPosition;
            
            // Click su indicatore per navigare
            indicator.addEventListener('click', (e) => {
                const rect = indicator.getBoundingClientRect();
                const clickRatio = (e.clientX - rect.left) / rect.width;
                const targetTime = clickRatio * totalDuration;
                
                // Centra la vista sul punto cliccato
                const newMin = Math.max(0, targetTime - 6);
                const newMax = Math.min(totalDuration, targetTime + 6);
                
                chart.scales.x.options.min = newMin;
                chart.scales.x.options.max = newMax;
                chart.update('none');
                updateThumbPosition();
            });
            
            // Drag per scorrere
            let isDragging = false;
            thumb.addEventListener('mousedown', (e) => {
                isDragging = true;
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const rect = indicator.getBoundingClientRect();
                const dragRatio = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
                const targetTime = dragRatio * totalDuration;
                
                const newMin = Math.max(0, targetTime - 6);
                const newMax = Math.min(totalDuration, newMin + 12);
                
                chart.scales.x.options.min = newMin;
                chart.scales.x.options.max = newMax;
                chart.update('none');
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
        }

        // üÜï Navigazione da tastiera
        function addKeyboardNavigation(chart, totalDuration) {
            const container = chart.canvas.parentElement;
            
            // Rendi il container focusable
            container.tabIndex = 0;
            container.style.outline = 'none';
            
            container.addEventListener('keydown', (e) => {
                if (!container.contains(document.activeElement)) return;
                
                const currentMin = chart.scales.x.min || 0;
                const currentMax = chart.scales.x.max || 12;
                const viewWidth = currentMax - currentMin;
                
                let newMin, newMax;
                
                switch(e.key) {
                    case 'ArrowLeft':
                        e.preventDefault();
                        newMin = Math.max(0, currentMin - 2);
                        newMax = newMin + viewWidth;
                        break;
                        
                    case 'ArrowRight':
                        e.preventDefault();
                        newMax = Math.min(totalDuration, currentMax + 2);
                        newMin = newMax - viewWidth;
                        break;
                        
                    case 'Home':
                        e.preventDefault();
                        newMin = 0;
                        newMax = Math.min(12, totalDuration);
                        break;
                        
                    case 'End':
                        e.preventDefault();
                        newMax = totalDuration;
                        newMin = Math.max(0, totalDuration - 12);
                        break;
                        
                    case '+':
                    case '=':
                        e.preventDefault();
                        // Zoom in
                        const zoomInWidth = viewWidth * 0.8;
                        const center = (currentMin + currentMax) / 2;
                        newMin = center - zoomInWidth / 2;
                        newMax = center + zoomInWidth / 2;
                        break;
                        
                    case '-':
                        e.preventDefault();
                        // Zoom out
                        const zoomOutWidth = Math.min(viewWidth * 1.25, totalDuration);
                        const centerOut = (currentMin + currentMax) / 2;
                        newMin = Math.max(0, centerOut - zoomOutWidth / 2);
                        newMax = Math.min(totalDuration, centerOut + zoomOutWidth / 2);
                        break;
                        
                    default:
                        return;
                }
                
                chart.scales.x.options.min = newMin;
                chart.scales.x.options.max = newMax;
                chart.update('none');
            });
            
            // Mostra suggerimenti controlli quando focused
            container.addEventListener('focus', () => {
                showNavigationHints(container);
            });
        }

        // üÜï Mostra suggerimenti navigazione
        function showNavigationHints(container) {
            const existing = container.querySelector('.navigation-hints');
            if (existing) return;
            
            const hints = document.createElement('div');
            hints.className = 'navigation-hints';
            hints.style.cssText = `
                position: absolute;
                top: 10px;
                left: 10px;
                background: rgba(0,0,0,0.8);
                color: white;
                padding: 8px 12px;
                border-radius: 6px;
                font-size: 11px;
                z-index: 25;
                pointer-events: none;
                opacity: 0;
                transition: opacity 0.3s ease;
            `;
            
            hints.innerHTML = `
                <div><strong>‚å®Ô∏è Controlli Tastiera:</strong></div>
                <div>‚Üê ‚Üí : Scorri timeline</div>
                <div>+ - : Zoom in/out</div>
                <div>Home/End : Inizio/Fine</div>
            `;
            
            container.appendChild(hints);
            
            // Fade in
            setTimeout(() => hints.style.opacity = '1', 10);
            
            // Fade out dopo 3 secondi
            setTimeout(() => {
                hints.style.opacity = '0';
                setTimeout(() => hints.remove(), 300);
            }, 3000);
        }

        // üÜï Aggiungi pulsante fullscreen per i grafici
        function addFullscreenButton(chart, chartId) {
            const container = chart.canvas.parentElement;
            
            const fullscreenBtn = document.createElement('button');
            fullscreenBtn.innerHTML = '‚õ∂';
            fullscreenBtn.title = 'Visualizzazione a schermo intero';
            fullscreenBtn.style.cssText = `
                position: absolute;
                top: 10px;
                right: 10px;
                background: rgba(255,255,255,0.9);
                border: 1px solid #ddd;
                border-radius: 4px;
                padding: 8px 12px;
                cursor: pointer;
                font-size: 16px;
                z-index: 20;
                transition: all 0.3s ease;
            `;
            
            fullscreenBtn.addEventListener('click', () => {
                if (container.requestFullscreen) {
                    container.requestFullscreen();
                } else if (container.webkitRequestFullscreen) {
                    container.webkitRequestFullscreen();
                } else if (container.msRequestFullscreen) {
                    container.msRequestFullscreen();
                }
            });
            
            fullscreenBtn.addEventListener('mouseenter', () => {
                fullscreenBtn.style.background = 'rgba(102, 126, 234, 0.1)';
                fullscreenBtn.style.borderColor = '#667eea';
            });
            
            fullscreenBtn.addEventListener('mouseleave', () => {
                fullscreenBtn.style.background = 'rgba(255,255,255,0.9)';
                fullscreenBtn.style.borderColor = '#ddd';
            });
            
            container.appendChild(fullscreenBtn);
        }
            const container = canvas.parentElement;
            
            // Rimuovi overlay esistenti
            const existingOverlays = container.querySelectorAll('.phrase-overlay');
            existingOverlays.forEach(overlay => overlay.remove());
            
            phrases.forEach((phrase, index) => {
                const displayText = generateSampleText(phrase.temporalAnalysis.trend, index, phrase.recognizedText);
                const overlay = document.createElement('div');
                overlay.className = 'phrase-overlay';
                
                // üÜï Posizionamento dinamico basato su timeline reale
                const realStartTime = phrase.startTime || (index * 2.5);
                const containerWidth = container.offsetWidth - 40; // Padding
                const timelineWidth = totalDuration;
                const relativePosition = (realStartTime / timelineWidth) * containerWidth;
                
                overlay.style.cssText = `
                    position: absolute;
                    background: rgba(255,255,255,0.95);
                    border: 2px solid ${getVoiceColor(phrase.temporalAnalysis.trend)};
                    border-radius: 8px;
                    padding: 8px 12px;
                    font-size: 11px;
                    font-weight: bold;
                    color: #333;
                    pointer-events: none;
                    z-index: 10;
                    max-width: 200px;
                    text-align: center;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
                    top: ${20 + (index % 3) * 65}px;
                    left: ${Math.min(relativePosition, containerWidth - 200)}px;
                `;
                
                overlay.innerHTML = `
                    <div style="color: ${getVoiceColor(phrase.temporalAnalysis.trend)}; font-size: 12px; margin-bottom: 4px;">
                        ${getVoiceEmoji(phrase.temporalAnalysis.trend)} Frase ${index + 1} (${phrase.duration.toFixed(1)}s)
                    </div>
                    <div style="font-style: italic; line-height: 1.2;">
                        "${displayText.substring(0, 35)}${displayText.length > 35 ? '...' : ''}"
                    </div>
                    ${phrase.recognizedText ? '' : '<div style="font-size: 9px; color: #999; margin-top: 2px;">‚ö†Ô∏è Simulato</div>'}
                `;
                
                container.style.position = 'relative';
                container.appendChild(overlay);
            });
        }

        // üÜï Funzione per aggiungere overlay delle frasi
        function addPhraseOverlays(canvas, phrases, chart) {
            const container = canvas.parentElement;
            
            // Rimuovi overlay esistenti
            const existingOverlays = container.querySelectorAll('.phrase-overlay');
            existingOverlays.forEach(overlay => overlay.remove());
            
            phrases.forEach((phrase, index) => {
                // üÜï Usa il testo appropriato per gli overlay
                const displayText = generateSampleText(phrase.temporalAnalysis.trend, index, phrase.recognizedText);
                const overlay = document.createElement('div');
                overlay.className = 'phrase-overlay';
                overlay.style.cssText = `
                    position: absolute;
                    background: rgba(255,255,255,0.95);
                    border: 2px solid ${getVoiceColor(phrase.temporalAnalysis.trend)};
                    border-radius: 8px;
                    padding: 8px 12px;
                    font-size: 11px;
                    font-weight: bold;
                    color: #333;
                    pointer-events: none;
                    z-index: 10;
                    max-width: 200px;
                    text-align: center;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
                    top: ${20 + (index * 60)}px;
                    left: ${50 + (index * 180)}px;
                `;
                
                overlay.innerHTML = `
                    <div style="color: ${getVoiceColor(phrase.temporalAnalysis.trend)}; font-size: 12px; margin-bottom: 4px;">
                        ${getVoiceEmoji(phrase.temporalAnalysis.trend)} Frase ${index + 1}
                    </div>
                    <div style="font-style: italic; line-height: 1.2;">
                        "${displayText}"
                    </div>
                    ${phrase.recognizedText ? '' : '<div style="font-size: 9px; color: #999; margin-top: 2px;">‚ö†Ô∏è Simulato</div>'}
                `;
                
                container.style.position = 'relative';
                container.appendChild(overlay);
            });
        }

        // üÜï Funzioni helper per colori ed emoji
        function getVoiceColor(trend) {
            const colors = {
                ascending: '#4682B4',
                descending: '#008B8B',
                stable: '#8B4513',
                dynamic: '#DC143C'
            };
            return colors[trend] || '#666';
        }

        function getVoiceEmoji(trend) {
            const emojis = {
                ascending: 'üå¨Ô∏è',
                descending: 'üíß',
                stable: 'üåç',
                dynamic: 'üî•'
            };
            return emojis[trend] || 'üé§';
        }

        // === EVENT HANDLERS ===
        function testMicrophone() {
            log('Test microfono avviato...');
            
            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(stream => {
                    log('Microfono accessibile ‚úÖ', 'success');
                    showMessage('Microfono funziona correttamente!');
                    stream.getTracks().forEach(track => track.stop());
                })
                .catch(error => {
                    log(`Errore microfono: ${error.message}`, 'error');
                    showMessage('Errore accesso microfono. Controlla i permessi.', 'error');
                });
        }

        function startRecording() {
            log('Avvio registrazione...');
            
            navigator.mediaDevices.getUserMedia({ 
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true
                }
            })
                .then(stream => {
                    app.recordingChunks = [];
                    app.recognizedPhrases = []; // Reset frasi riconosciute
                    
                    app.mediaRecorder = new MediaRecorder(stream);
                    app.isRecording = true;
                    app.recordingStartTime = Date.now();
                    
                    // üÜï Avvia riconoscimento vocale se supportato
                    startSpeechRecognition();
                    
                    // Aggiorna timer
                    app.recordingTimer = setInterval(updateRecordingTimer, 100);
                    
                    app.mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            app.recordingChunks.push(event.data);
                        }
                    };
                    
                    app.mediaRecorder.onstop = () => {
                        const audioBlob = new Blob(app.recordingChunks, { type: 'audio/wav' });
                        convertBlobToAudioData(audioBlob);
                        stream.getTracks().forEach(track => track.stop());
                        stopSpeechRecognition(); // Ferma riconoscimento
                    };
                    
                    app.mediaRecorder.start(100); // Raccoglie dati ogni 100ms
                    
                    log('Registrazione avviata', 'success');
                    
                    // üÜï Messaggio differenziato in base al supporto Speech Recognition
                    if (app.isRecognitionEnabled) {
                        showMessage('Registrazione + Riconoscimento vocale attivi... Parla chiaramente!');
                    } else {
                        showMessage('Registrazione in corso... (Riconoscimento vocale non supportato - analisi solo audio)');
                    }
                    
                    // Aggiorna UI
                    document.getElementById('startRecording').disabled = true;
                    document.getElementById('stopRecording').disabled = false;
                    document.getElementById('startRecording').classList.add('recording');
                    
                    // Simula visualizzatore audio
                    animateAudioBars();
                })
                .catch(error => {
                    log(`Errore registrazione: ${error.message}`, 'error');
                    showMessage('Errore durante la registrazione. Controlla i permessi del microfono.', 'error');
                });
        }

        // üÜï Avvia riconoscimento vocale
        function startSpeechRecognition() {
            // Controlla supporto Speech Recognition
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            
            if (!SpeechRecognition) {
                log('Speech Recognition non supportato in questo browser', 'warning');
                app.isRecognitionEnabled = false;
                return;
            }
            
            app.speechRecognition = new SpeechRecognition();
            app.speechRecognition.continuous = true;
            app.speechRecognition.interimResults = true;
            app.speechRecognition.lang = 'it-IT'; // Italiano
            
            app.speechRecognition.onstart = () => {
                app.isRecognitionEnabled = true;
                log('Riconoscimento vocale avviato', 'success');
            };
            
            app.speechRecognition.onresult = (event) => {
                let finalTranscript = '';
                
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const result = event.results[i];
                    if (result.isFinal) {
                        finalTranscript += result[0].transcript + ' ';
                    }
                }
                
                if (finalTranscript.trim()) {
                    app.recognizedPhrases.push({
                        text: finalTranscript.trim(),
                        timestamp: Date.now() - app.recordingStartTime,
                        confidence: event.results[event.results.length - 1][0].confidence || 0.8
                    });
                    
                    log(`Frase riconosciuta: "${finalTranscript.trim()}"`, 'success');
                }
            };
            
            app.speechRecognition.onerror = (event) => {
                log(`Errore riconoscimento vocale: ${event.error}`, 'warning');
            };
            
            app.speechRecognition.onend = () => {
                app.isRecognitionEnabled = false;
                log('Riconoscimento vocale terminato');
            };
            
            try {
                app.speechRecognition.start();
            } catch (error) {
                log(`Impossibile avviare riconoscimento vocale: ${error.message}`, 'warning');
                app.isRecognitionEnabled = false;
            }
        }

        // üÜï Ferma riconoscimento vocale
        function stopSpeechRecognition() {
            if (app.speechRecognition && app.isRecognitionEnabled) {
                app.speechRecognition.stop();
                log(`Riconoscimento completato. Frasi catturate: ${app.recognizedPhrases.length}`);
            }
        }

        function stopRecording() {
            if (app.isRecording && app.mediaRecorder) {
                app.mediaRecorder.stop();
                app.isRecording = false;
                
                if (app.recordingTimer) {
                    clearInterval(app.recordingTimer);
                    app.recordingTimer = null;
                }
                
                log('Registrazione fermata', 'success');
                
                // Aggiorna UI
                document.getElementById('startRecording').disabled = false;
                document.getElementById('stopRecording').disabled = true;
                document.getElementById('startRecording').classList.remove('recording');
                
                // Ferma animazione audio bars
                stopAudioBarsAnimation();
            }
        }

        function convertBlobToAudioData(blob) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const arrayBuffer = e.target.result;
                
                // üÜï PROCESSAMENTO REALE DELL'AUDIO invece di simulazione
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                audioContext.decodeAudioData(arrayBuffer)
                    .then(audioBuffer => {
                        // Ottieni il canale audio (mono)
                        const channelData = audioBuffer.getChannelData(0);
                        
                        // Converti in Float32Array per la nostra analisi
                        app.currentAudioData = new Float32Array(channelData.length);
                        for (let i = 0; i < channelData.length; i++) {
                            app.currentAudioData[i] = channelData[i];
                        }
                        
                        const duration = audioBuffer.duration;
                        
                        document.getElementById('analyzePhrases').disabled = false;
                        document.getElementById('autoDetectVoice').disabled = false;
                        
                        showMessage(`Audio processato: ${duration.toFixed(1)}s (${channelData.length} campioni)`);
                        log(`Audio REALE processato: ${duration.toFixed(1)}s, ${channelData.length} campioni`, 'success');
                    })
                    .catch(error => {
                        log(`Errore decodifica audio: ${error.message}`, 'error');
                        
                        // Fallback: simulazione migliorata basata sulla durata reale
                        const duration = (Date.now() - app.recordingStartTime) / 1000;
                        app.currentAudioData = generateRealisticAudioSimulation(duration);
                        
                        document.getElementById('analyzePhrases').disabled = false;
                        document.getElementById('autoDetectVoice').disabled = false;
                        
                        showMessage(`Audio simulato: ${duration.toFixed(1)}s (fallback)`);
                        log(`Fallback su simulazione audio: ${duration.toFixed(1)}s`, 'warning');
                    });
            };
            reader.readAsArrayBuffer(blob);
        }

        // üÜï Genera simulazione audio pi√π realistica
        function generateRealisticAudioSimulation(durationSeconds) {
            const sampleRate = 44100;
            const totalSamples = Math.floor(durationSeconds * sampleRate);
            const audioData = new Float32Array(totalSamples);
            
            // Simula un discorso con pause naturali
            const pauseProbability = 0.15; // 15% di possibilit√† di pausa per ogni 100ms
            let currentVolume = 0.1;
            let isInPause = false;
            let pauseCountdown = 0;
            
            for (let i = 0; i < totalSamples; i++) {
                const timePosition = i / sampleRate;
                
                // Ogni 100ms, decidi se iniziare/finire una pausa
                if (i % (sampleRate / 10) === 0) {
                    if (!isInPause && Math.random() < pauseProbability) {
                        isInPause = true;
                        pauseCountdown = Math.floor(0.3 * sampleRate + Math.random() * 0.8 * sampleRate); // Pause 0.3-1.1s
                    }
                }
                
                if (isInPause) {
                    currentVolume = 0.01; // Quasi silenzio
                    pauseCountdown--;
                    if (pauseCountdown <= 0) {
                        isInPause = false;
                    }
                } else {
                    // Volume normale con variazioni naturali
                    currentVolume = 0.05 + Math.random() * 0.15 + 0.05 * Math.sin(timePosition * 3);
                }
                
                // Genera rumore audio con il volume calcolato
                audioData[i] = (Math.random() - 0.5) * 2 * currentVolume;
            }
            
            log(`Generata simulazione audio realistica: ${durationSeconds.toFixed(1)}s con pause naturali`);
            return audioData;
        }

        function animateAudioBars() {
            if (!app.isRecording) return;
            
            const bars = document.querySelectorAll('.audio-bar');
            bars.forEach(bar => {
                const height = Math.random() * 50 + 5;
                bar.style.height = `${height}px`;
            });
            
            if (app.isRecording) {
                setTimeout(animateAudioBars, 100);
            }
        }

        function stopAudioBarsAnimation() {
            const bars = document.querySelectorAll('.audio-bar');
            bars.forEach(bar => {
                bar.style.height = '2px';
            });
        }

        function autoDetectVoice() {
            if (!app.currentAudioData) {
                showMessage('Nessun audio da analizzare. Registra prima un audio.', 'error');
                return;
            }
            
            log('Iniziando auto-rilevamento voce...');
            showProcessing(true, 'Analizzando automaticamente la voce...');
            
            setTimeout(() => {
                const phrases = detectPhrases(app.currentAudioData);
                const classification = classifyVoice(phrases);
                
                // Mostra risultati
                document.getElementById('autoDetectionResult').style.display = 'block';
                
                const voiceEmojis = { ARIA: 'üå¨Ô∏è', ACQUA: 'üíß', TERRA: 'üåç', FUOCO: 'üî•' };
                document.getElementById('detectedVoice').textContent = 
                    `${voiceEmojis[classification.detectedVoice]} ${classification.detectedVoice}`;
                
                document.getElementById('confidenceScore').textContent = 
                    `Precisione: ${(classification.confidence * 100).toFixed(1)}%`;
                
                document.getElementById('scoreAria').textContent = `${classification.scores.ARIA.toFixed(1)}%`;
                document.getElementById('scoreAcqua').textContent = `${classification.scores.ACQUA.toFixed(1)}%`;
                document.getElementById('scoreTerra').textContent = `${classification.scores.TERRA.toFixed(1)}%`;
                document.getElementById('scoreFuoco').textContent = `${classification.scores.FUOCO.toFixed(1)}%`;
                
                showProcessing(false);
                showMessage(`Voce rilevata: ${classification.detectedVoice} con precisione ${(classification.confidence * 100).toFixed(1)}%`);
            }, 1500);
        }

        function analyzePhrases() {
            if (!app.currentAudioData) {
                showMessage('Nessun audio da analizzare. Registra o carica un file audio.', 'error');
                return;
            }
            
            log('Iniziando analisi frasi dettagliata...');
            showProcessing(true, 'Analizzando le frasi...');
            
            setTimeout(() => {
                const phrases = detectPhrases(app.currentAudioData);
                const classification = classifyVoice(phrases);
                
                if (phrases.length === 0) {
                    showMessage('Nessuna frase rilevata. Prova a registrare di nuovo.', 'error');
                    showProcessing(false);
                    return;
                }
                
                app.currentPhrases = phrases;
                
                // üÜï GARANTISCE COERENZA tra auto-detection e summary
                
                // Aggiorna auto-detection result per coerenza
                const autoDetectionDiv = document.getElementById('autoDetectionResult');
                if (autoDetectionDiv) {
                    autoDetectionDiv.style.display = 'block';
                    
                    const voiceEmojis = { ARIA: 'üå¨Ô∏è', ACQUA: 'üíß', TERRA: 'üåç', FUOCO: 'üî•' };
                    document.getElementById('detectedVoice').textContent = 
                        `${voiceEmojis[classification.detectedVoice]} ${classification.detectedVoice}`;
                    
                    document.getElementById('confidenceScore').textContent = 
                        `Precisione: ${(classification.confidence * 100).toFixed(1)}%`;
                    
                    document.getElementById('scoreAria').textContent = `${classification.scores.ARIA.toFixed(1)}%`;
                    document.getElementById('scoreAcqua').textContent = `${classification.scores.ACQUA.toFixed(1)}%`;
                    document.getElementById('scoreTerra').textContent = `${classification.scores.TERRA.toFixed(1)}%`;
                    document.getElementById('scoreFuoco').textContent = `${classification.scores.FUOCO.toFixed(1)}%`;
                }
                
                // Aggiorna summary con STESSA classificazione
                document.getElementById('phraseResults').style.display = 'block';
                document.getElementById('totalPhrases').textContent = phrases.length;
                
                // üî• CONSISTENCY FIX: Usa SEMPRE la stessa voce dominante
                document.getElementById('dominantVoice').textContent = `üé§ ${classification.detectedVoice}`;
                
                document.getElementById('avgPhraseDuration').textContent = 
                    `${(phrases.reduce((sum, p) => sum + p.duration, 0) / phrases.length).toFixed(1)}s`;
                document.getElementById('overallClarity').textContent = 
                    classification.confidence > 0.7 ? 'Alta' : classification.confidence > 0.5 ? 'Media' : 'Bassa';
                
                // Crea cards frasi
                const container = document.getElementById('phraseInfoGrid');
                container.innerHTML = '';
                
                const trendDescriptions = {
                    ascending: 'üìà Crescente',
                    descending: 'üìâ Calante',
                    stable: '‚û°Ô∏è Stabile',
                    dynamic: 'üé¢ Dinamico'
                };
                
                phrases.forEach((phrase, index) => {
                    const card = document.createElement('div');
                    card.className = `phrase-card trend-${phrase.temporalAnalysis.trend}`;
                    
                    // üÜï Usa il testo riconosciuto se disponibile, altrimenti genera sample
                    const displayText = generateSampleText(phrase.temporalAnalysis.trend, index, phrase.recognizedText);
                    
                    card.innerHTML = `
                        <div class="phrase-title">Frase ${phrase.index + 1}</div>
                        <div class="phrase-trend trend-${phrase.temporalAnalysis.trend}">
                            ${trendDescriptions[phrase.temporalAnalysis.trend]}
                        </div>
                        <div>Durata: ${phrase.duration.toFixed(1)}s</div>
                        <div>Cambio: ${phrase.temporalAnalysis.volumeChange > 0 ? '+' : ''}${phrase.temporalAnalysis.volumeChange.toFixed(1)}dB</div>
                        <div>Media: ${phrase.temporalAnalysis.avgVolume.toFixed(1)}dB</div>
                        <div style="margin-top: 8px; font-style: italic; color: #666; font-size: 12px;">
                            "${displayText}"
                        </div>
                        ${phrase.recognizedText ? '' : '<div style="font-size: 10px; color: #999; margin-top: 4px;">‚ö†Ô∏è Testo simulato - Speech-to-Text non implementato</div>'}
                        <div class="phrase-controls">
                            <button class="speak-btn" data-phrase-index="${index}">
                                <span>üîä</span>
                                Ascolta
                            </button>
                        </div>
                    `;
                    
                    const speakBtn = card.querySelector('.speak-btn');
                    speakBtn.addEventListener('click', () => speakText(displayText, index));
                    
                    container.appendChild(card);
                });
                
                // Crea grafici
                createChart(phrases, 'volumeTrendChart', 'üìà Andamento Temporale delle Voci - Timeline Completa');
                createChart(phrases, 'individualPhrasesChart', 'üé≠ Sequenza delle Voci nel Tempo - Confronto Diretto');
                
                // Abilita TTS per tutte le frasi
                document.getElementById('speakAllPhrases').disabled = false;
                
                showProcessing(false);
                showMessage(`Analisi completata: ${phrases.length} frasi rilevate. Voce dominante: ${classification.detectedVoice}`);
                
                // üÜï LOG FINALE per debug
                log(`Analisi completata. Coerenza verificata: Auto-detection e Summary mostrano entrambi ${classification.detectedVoice}`, 'success');
                
            }, 2000);
        }

        function speakAllPhrases() {
            if (app.isSpeaking) {
                app.speechSynth.cancel();
                app.isSpeaking = false;
                document.getElementById('speakAllPhrases').innerHTML = '<span>üé§</span>Leggi Tutte le Frasi';
                return;
            }
            
            if (app.currentPhrases.length === 0) return;
            
            app.isSpeaking = true;
            document.getElementById('speakAllPhrases').innerHTML = '<span>‚èπÔ∏è</span>Ferma Lettura';
            
            let currentIndex = 0;
            
            function speakNext() {
                if (currentIndex >= app.currentPhrases.length || !app.isSpeaking) {
                    app.isSpeaking = false;
                    document.getElementById('speakAllPhrases').innerHTML = '<span>üé§</span>Leggi Tutte le Frasi';
                    return;
                }
                
                const phrase = app.currentPhrases[currentIndex];
                const sampleText = generateSampleText(phrase.temporalAnalysis.trend);
                
                const utterance = new SpeechSynthesisUtterance(sampleText);
                
                // Configura TTS
                const rate = document.getElementById('speechRate')?.value || 1;
                const pitch = document.getElementById('speechPitch')?.value || 1;
                const volume = document.getElementById('speechVolume')?.value || 0.8;
                
                utterance.rate = parseFloat(rate);
                utterance.pitch = parseFloat(pitch);
                utterance.volume = parseFloat(volume);
                
                utterance.onend = () => {
                    currentIndex++;
                    setTimeout(speakNext, 500);
                };
                
                app.speechSynth.speak(utterance);
                log(`TTS: "${sampleText}" (Frase ${currentIndex + 1})`);
            }
            
            speakNext();
        }

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.type.startsWith('audio/')) {
                showMessage('Seleziona un file audio valido.', 'error');
                return;
            }
            
            log(`Caricamento file: ${file.name}`);
            showProcessing(true, 'Caricamento file audio...');
            
            const reader = new FileReader();
            reader.onload = function(e) {
                // Simula caricamento e conversione
                setTimeout(() => {
                    app.currentAudioData = new Float32Array(44100 * 5); // 5 secondi simulati
                    for (let i = 0; i < app.currentAudioData.length; i++) {
                        app.currentAudioData[i] = (Math.random() - 0.5) * 0.1;
                    }
                    
                    document.getElementById('analyzePhrases').disabled = false;
                    document.getElementById('autoDetectVoice').disabled = false;
                    
                    showProcessing(false);
                    showMessage(`File caricato: ${file.name} (5.0s)`);
                    log('File caricato con successo', 'success');
                }, 1000);
            };
            
            reader.onerror = () => {
                showProcessing(false);
                showMessage('Errore durante il caricamento del file.', 'error');
                log('Errore caricamento file', 'error');
            };
            
            reader.readAsArrayBuffer(file);
        }

        function selectVoice(voiceName) {
            document.querySelectorAll('.voice-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            const selectedCard = document.querySelector(`[data-voice="${voiceName}"]`);
            if (selectedCard) selectedCard.classList.add('selected');
            
            log(`Voce selezionata: ${voiceName}`, 'success');
        }

        function clearResults() {
            document.getElementById('phraseResults').style.display = 'none';
            document.getElementById('autoDetectionResult').style.display = 'none';
            document.getElementById('analyzePhrases').disabled = true;
            document.getElementById('autoDetectVoice').disabled = true;
            document.getElementById('speakAllPhrases').disabled = true;
            document.getElementById('recordingTime').textContent = '00:00';
            
            if (app.isSpeaking) {
                app.speechSynth.cancel();
                app.isSpeaking = false;
            }
            
            app.currentAudioData = null;
            app.currentPhrases = [];
            
            if (app.volumeTrendChart) {
                app.volumeTrendChart.destroy();
                app.volumeTrendChart = null;
            }
            
            if (app.individualPhrasesChart) {
                app.individualPhrasesChart.destroy();
                app.individualPhrasesChart = null;
            }
            
            // Reset file input
            document.getElementById('fileInput').value = '';
            
            document.getElementById('debugLog').innerHTML = 'Log pulito...<br>';
            log('Risultati puliti', 'success');
        }

        function setupTTS() {
            if (!app.speechSynth) {
                log('Speech Synthesis non disponibile', 'warning');
                return;
            }
            
            function loadVoices() {
                app.availableVoices = app.speechSynth.getVoices();
                const voiceSelect = document.getElementById('speechVoice');
                
                if (voiceSelect) {
                    voiceSelect.innerHTML = '<option value="">Default</option>';
                    
                    app.availableVoices.forEach((voice, index) => {
                        const option = document.createElement('option');
                        option.value = index;
                        option.textContent = `${voice.name} (${voice.lang})`;
                        voiceSelect.appendChild(option);
                    });
                    
                    log(`Caricate ${app.availableVoices.length} voci TTS`, 'success');
                }
            }
            
            if (app.speechSynth.getVoices().length > 0) {
                loadVoices();
            } else {
                app.speechSynth.addEventListener('voiceschanged', loadVoices);
            }
        }

        function setupAudioVisualizer() {
            const visualizer = document.getElementById('audioVisualizer');
            if (visualizer) {
                visualizer.innerHTML = '';
                for (let i = 0; i < 50; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'audio-bar';
                    bar.style.left = `${i * 4}px`;
                    bar.style.height = '2px';
                    visualizer.appendChild(bar);
                }
            }
        }

        // === INIZIALIZZAZIONE ===
        document.addEventListener('DOMContentLoaded', function() {
            log('Voice Break AI inizializzata!', 'success');
            
            // Setup event listeners
            document.getElementById('testMicrophone').addEventListener('click', testMicrophone);
            document.getElementById('startRecording').addEventListener('click', startRecording);
            document.getElementById('stopRecording').addEventListener('click', stopRecording);
            document.getElementById('autoDetectVoice').addEventListener('click', autoDetectVoice);
            document.getElementById('analyzePhrases').addEventListener('click', analyzePhrases);
            document.getElementById('clearResults').addEventListener('click', clearResults);
            document.getElementById('fileInput').addEventListener('change', handleFileUpload);
            document.getElementById('speakAllPhrases').addEventListener('click', speakAllPhrases);
            
            // Voice cards
            document.querySelectorAll('.voice-card').forEach(card => {
                card.addEventListener('click', () => selectVoice(card.dataset.voice));
            });
            
            // Setup componenti
            setupTTS();
            setupAudioVisualizer();
            
            // Controllo compatibilit√† browser
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                log('MediaDevices API non supportata', 'error');
                showMessage('Browser non compatibile. Usa Chrome o Firefox.', 'error');
                return;
            }
            
            if (typeof MediaRecorder === 'undefined') {
                log('MediaRecorder non supportato', 'error');
                showMessage('MediaRecorder non supportato. Aggiorna il browser.', 'error');
                return;
            }
            
            log('Browser compatibile ‚úÖ', 'success');
            log('Tutti i sistemi operativi. App pronta per l\'uso!', 'success');
        });
    </script>
</body>
</html>